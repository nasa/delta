<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>delta.imagery.sources.landsat API documentation</title>
<meta name="description" content="Read Landsat images." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>delta.imagery.sources.landsat</code></h1>
</header>
<section id="section-intro">
<p>Read Landsat images.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright Â© 2020, United States Government, as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All rights reserved.
#
# The DELTA (Deep Earth Learning, Tools, and Analysis) platform is
# licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;
Read Landsat images.
&#34;&#34;&#34;

import math
import functools
import os
import os.path
import numpy as np

from delta.config import config
from delta.imagery import utilities
from . import tiff

# Use this for all the output Landsat data we write.
OUTPUT_NODATA = 0.0

def _allocate_bands_for_spacecraft(landsat_number):
    &#34;&#34;&#34;Set up value storage for _parse_mtl_file()&#34;&#34;&#34;

    BAND_COUNTS = {&#39;5&#39;:7, &#39;7&#39;:9, &#39;8&#39;:11}

    num_bands = BAND_COUNTS[landsat_number]
    data = dict()

    # There are fewer K constants but we store in the the
    # appropriate band indices.
    data[&#39;FILE_NAME&#39;       ] = [&#39;&#39;] * num_bands
    data[&#39;RADIANCE_MULT&#39;   ] = [None] * num_bands
    data[&#39;RADIANCE_ADD&#39;    ] = [None] * num_bands
    data[&#39;REFLECTANCE_MULT&#39;] = [None] * num_bands
    data[&#39;REFLECTANCE_ADD&#39; ] = [None] * num_bands
    data[&#39;K1_CONSTANT&#39;     ] = [None] * num_bands
    data[&#39;K2_CONSTANT&#39;     ] = [None] * num_bands

    return data

def _parse_mtl_file(mtl_path):
    &#34;&#34;&#34;Parse out the needed values from the MTL file&#34;&#34;&#34;

    if not os.path.exists(mtl_path):
        raise Exception(&#39;MTL file not found: &#39; + mtl_path)

    # These are all the values we want to read in
    DESIRED_TAGS = [&#39;FILE_NAME&#39;, &#39;RADIANCE_MULT&#39;, &#39;RADIANCE_ADD&#39;,
                    &#39;REFLECTANCE_MULT&#39;, &#39;REFLECTANCE_ADD&#39;,
                    &#39;K1_CONSTANT&#39;, &#39;K2_CONSTANT&#39;]

    data = None
    with open(mtl_path, &#39;r&#39;) as f:
        for line in f:

            line = line.replace(&#39;&#34;&#39;,&#39;&#39;) # Clean up

            # Get the spacecraft ID and allocate storage
            if &#39;SPACECRAFT_ID = LANDSAT_&#39; in line:
                spacecraft_id = line.split(&#39;_&#39;)[-1].strip()
                data = _allocate_bands_for_spacecraft(spacecraft_id)

            if &#39;SUN_ELEVATION = &#39; in line:
                value = line.split(&#39;=&#39;)[-1].strip()
                data[&#39;SUN_ELEVATION&#39;] = float(value)

            # Look for the other info we want
            for tag in DESIRED_TAGS:
                t = tag + &#39;_BAND&#39;
                if t in line: # TODO: Better to do regex here

                    # Break out the name, value, and band
                    parts = line.split(&#39;=&#39;)
                    name  = parts[0].strip()
                    value = parts[1].strip()
                    try:
                        # Landsat 7 has two thermal readings from the same wavelength band
                        # bit with different gain settings.  Just treat the second file
                        # as another band (9).
                        name = name.replace(&#39;BAND_6_VCID_1&#39;, &#39;BAND_6&#39;)
                        name = name.replace(&#39;BAND_6_VCID_2&#39;, &#39;BAND_9&#39;)
                        band  = int(name.split(&#39;_&#39;)[-1]) -1 # One-based to zero-based
                    except ValueError: # Means this is not a proper match
                        break

                    if tag == &#39;FILE_NAME&#39;:
                        data[tag][band] = value # String
                    else:
                        data[tag][band] = float(value)

    return data


def get_scene_info(path):
    &#34;&#34;&#34;Extract information about the landsat scene from the file name&#34;&#34;&#34;
    fname  = os.path.basename(path)
    parts  = fname.split(&#39;_&#39;)
    output = {}
    output[&#39;sensor&#39;] = parts[0]
    output[&#39;lpath&#39; ] = parts[2][0:3]
    output[&#39;lrow&#39;  ] = parts[2][3:6]
    output[&#39;date&#39;  ] = parts[3]
    return output

def _get_landsat_bands_to_use(sensor_name):
    &#34;&#34;&#34;Return the list of one-based band indices that we are currently
       using to process the given landsat sensor.
    &#34;&#34;&#34;

    # For now just the 30 meter bands, in original order.
    LS5_DESIRED_BANDS = [1, 2, 3, 4, 5, 6, 7]
    LS7_DESIRED_BANDS = [1, 2, 3, 4, 5, 6, 7] # Don&#39;t forget the extra thermal band!
    LS8_DESIRED_BANDS = [1, 2, 3, 4, 5, 6, 7, 9]

    if &#39;5&#39; in sensor_name:
        bands = LS5_DESIRED_BANDS
    else:
        if &#39;7&#39; in sensor_name:
            bands = LS7_DESIRED_BANDS
        else:
            if &#39;8&#39; in sensor_name:
                bands = LS8_DESIRED_BANDS
            else:
                raise Exception(&#39;Unknown landsat type: &#39; + sensor_name)
    return bands

def _get_band_paths(mtl_data, folder, bands_to_use=None):
    &#34;&#34;&#34;Return full paths to all band files that should be in the folder.
       Optionally specify a list of bands to use, otherwise all are used&#34;&#34;&#34;

    paths = []
    if not bands_to_use: # Default is to use all bands
        bands_to_use = range(1,len(mtl_data[&#39;FILE_NAME&#39;])+1)
    for b in bands_to_use:
        filename = mtl_data[&#39;FILE_NAME&#39;][b-1]
        band_path = os.path.join(folder, filename)
        paths.append(band_path)
    return paths

def _check_if_files_present(mtl_data, folder, bands_to_use=None):
    &#34;&#34;&#34;Return True if all the files associated with the MTL data are present.&#34;&#34;&#34;

    band_paths = _get_band_paths(mtl_data, folder, bands_to_use)
    for b in band_paths:
        if not os.path.exists(b):
            return False
    return True

def _find_mtl_file(folder):
    &#34;&#34;&#34;Returns the path to the MTL file in a folder.
       Returns None if there is no MTL file.
       Raises an Exception if there are multiple MTL files.&#34;&#34;&#34;

    file_list = os.listdir(folder)
    meta_files = [f for f in file_list if &#39;_MTL.txt&#39; in f]
    if len(meta_files) &gt; 1:
        raise Exception(&#39;Error: Too many MTL files in &#39;, folder, &#39;, file list: &#39;, str(file_list))
    if not meta_files:
        return None
    return os.path.join(folder, meta_files[0])


class LandsatImage(tiff.TiffImage):
    &#34;&#34;&#34;Compressed Landsat image tensorflow dataset wrapper (see imagery_dataset.py)&#34;&#34;&#34;


    def _prep(self, paths):
        &#34;&#34;&#34;Prepares a Landsat file from the archive for processing.
           Returns [band, paths, in, order, ...]
           Uses the bands specified in _get_landsat_bands_to_use()
           TODO: Handle bands which are not 30 meters!
           TODO: Apply TOA conversion!
        &#34;&#34;&#34;
        scene_info = get_scene_info(paths)
        self._sensor = scene_info[&#39;sensor&#39;]
        self._lpath = scene_info[&#39;lpath&#39;]
        self._lrow = scene_info[&#39;lrow&#39;]
        self._date = scene_info[&#39;date&#39;]

        # Get the folder where this will be stored from the cache manager
        name = &#39;_&#39;.join([self._sensor, self._lpath, self._lrow, self._date])
        untar_folder = config.cache_manager().register_item(name)

        # Check if we already unpacked this data
        all_files_present = False
        if os.path.exists(untar_folder):
            mtl_path = _find_mtl_file(untar_folder)
            if mtl_path:
                mtl_data = _parse_mtl_file(mtl_path)
                all_files_present = _check_if_files_present(mtl_data, untar_folder)

        if all_files_present:
            print(&#39;Already have unpacked files in &#39; + untar_folder)
        else:
            print(&#39;Unpacking tar file &#39; + paths + &#39; to folder &#39; + untar_folder)
            utilities.unpack_to_folder(paths, untar_folder)

        bands_to_use = _get_landsat_bands_to_use(self._sensor)

        # Generate all the band file names (the MTL file is not returned)
        self._mtl_path = _find_mtl_file(untar_folder)
        self._mtl_data = _parse_mtl_file(self._mtl_path)
        output_paths = _get_band_paths(self._mtl_data, untar_folder, bands_to_use)

        # Check that the files exist
        for p in output_paths:
            if not os.path.exists(p):
                raise Exception(&#39;Did not find expected file: &#39; + p
                                + &#39; after unpacking tar file &#39; + paths)

        return output_paths

    def radiance_mult(self):
        return self._mtl_data[&#39;RADIANCE_MULT&#39;]
    def radiance_add(self):
        return self._mtl_data[&#39;RADIANCE_ADD&#39;]
    def reflectance_mult(self):
        return self._mtl_data[&#39;REFLECTANCE_MULT&#39;]
    def reflectance_add(self):
        return self._mtl_data[&#39;REFLECTANCE_ADD&#39;]
    def k1_constant(self):
        return self._mtl_data[&#39;K1_CONSTANT&#39;]
    def k2_constant(self):
        return self._mtl_data[&#39;K2_CONSTANT&#39;]
    def sun_elevation(self):
        return self._mtl_data[&#39;SUN_ELEVATION&#39;]

# top of atmosphere correction
def _apply_toa_radiance(data, _, bands, factors, constants):
    &#34;&#34;&#34;Apply a top of atmosphere radiance conversion to landsat data&#34;&#34;&#34;
    buf = np.zeros(data.shape, dtype=np.float32)
    for b in bands:
        f = factors[b]
        c = constants[b]
        buf[:, :, b] = np.where(data[:, :, b] &gt; 0, data[:, :, b] * f + c, OUTPUT_NODATA)
    return buf

def _apply_toa_temperature(data, _, bands, factors, constants, k1, k2):
    &#34;&#34;&#34;Apply a top of atmosphere radiance + temp conversion to landsat data&#34;&#34;&#34;
    buf = np.zeros(data.shape, dtype=np.float32)
    for b in bands:
        f = factors[b]
        c = constants[b]
        k1 = k1[b]
        k2 = k2[b]
        buf[:, :, b] = np.where(data[:, :, b] &gt; 0, k2 / np.log(k1 / (data[:, :, b] * f + c) + 1.0), OUTPUT_NODATA)
    return buf

def _apply_toa_reflectance(data, _, bands, factors, constants, sun_elevation):
    &#34;&#34;&#34;Apply a top of atmosphere radiance + temp conversion to landsat data&#34;&#34;&#34;
    buf = np.zeros(data.shape, dtype=np.float32)
    for b in bands:
        f = factors[b]
        c = constants[b]
        se = sun_elevation[b]
        buf[:, :, b] = np.where(data[:, :, b] &gt; 0, (data[:, :, b] * f + c) / math.sin(se), OUTPUT_NODATA)
    return buf

def toa_preprocess(image, calc_reflectance=False):
    &#34;&#34;&#34;Convert landsat files in one folder to TOA corrected files in the output folder.
       Using the reflectance calculation is slightly more complicated but may be more useful.
       Multiprocessing is used if multiple processes are specified.&#34;&#34;&#34;

    if calc_reflectance:
        if image.k1_constant() is None:
            user_function = functools.partial(_apply_toa_reflectance, factors=image.reflectance_mult(),
                                              constants=image.reflectance_add(),
                                              sun_elevation=math.radians(image.sun_elevation()))
        else:
            user_function = functools.partial(_apply_toa_temperature, factors=image.radiance_mult(),
                                              constants=image.radiance_add(), k1=image.k1_constant(),
                                              k2=image.k2_constant())
    else:
        user_function = functools.partial(_apply_toa_radiance, factors=image.radiance_mult(),
                                          constants=image.radiance_add())

    image.set_preprocess(user_function)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="delta.imagery.sources.landsat.get_scene_info"><code class="name flex">
<span>def <span class="ident">get_scene_info</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract information about the landsat scene from the file name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_scene_info(path):
    &#34;&#34;&#34;Extract information about the landsat scene from the file name&#34;&#34;&#34;
    fname  = os.path.basename(path)
    parts  = fname.split(&#39;_&#39;)
    output = {}
    output[&#39;sensor&#39;] = parts[0]
    output[&#39;lpath&#39; ] = parts[2][0:3]
    output[&#39;lrow&#39;  ] = parts[2][3:6]
    output[&#39;date&#39;  ] = parts[3]
    return output</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.landsat.toa_preprocess"><code class="name flex">
<span>def <span class="ident">toa_preprocess</span></span>(<span>image, calc_reflectance=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert landsat files in one folder to TOA corrected files in the output folder.
Using the reflectance calculation is slightly more complicated but may be more useful.
Multiprocessing is used if multiple processes are specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toa_preprocess(image, calc_reflectance=False):
    &#34;&#34;&#34;Convert landsat files in one folder to TOA corrected files in the output folder.
       Using the reflectance calculation is slightly more complicated but may be more useful.
       Multiprocessing is used if multiple processes are specified.&#34;&#34;&#34;

    if calc_reflectance:
        if image.k1_constant() is None:
            user_function = functools.partial(_apply_toa_reflectance, factors=image.reflectance_mult(),
                                              constants=image.reflectance_add(),
                                              sun_elevation=math.radians(image.sun_elevation()))
        else:
            user_function = functools.partial(_apply_toa_temperature, factors=image.radiance_mult(),
                                              constants=image.radiance_add(), k1=image.k1_constant(),
                                              k2=image.k2_constant())
    else:
        user_function = functools.partial(_apply_toa_radiance, factors=image.radiance_mult(),
                                          constants=image.radiance_add())

    image.set_preprocess(user_function)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="delta.imagery.sources.landsat.LandsatImage"><code class="flex name class">
<span>class <span class="ident">LandsatImage</span></span>
<span>(</span><span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Compressed Landsat image tensorflow dataset wrapper (see imagery_dataset.py)</p>
<p>Opens a geotiff for reading. paths can be either a single filename or a list.
For a list, the images are opened in order as a multi-band image, assumed to overlap.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LandsatImage(tiff.TiffImage):
    &#34;&#34;&#34;Compressed Landsat image tensorflow dataset wrapper (see imagery_dataset.py)&#34;&#34;&#34;


    def _prep(self, paths):
        &#34;&#34;&#34;Prepares a Landsat file from the archive for processing.
           Returns [band, paths, in, order, ...]
           Uses the bands specified in _get_landsat_bands_to_use()
           TODO: Handle bands which are not 30 meters!
           TODO: Apply TOA conversion!
        &#34;&#34;&#34;
        scene_info = get_scene_info(paths)
        self._sensor = scene_info[&#39;sensor&#39;]
        self._lpath = scene_info[&#39;lpath&#39;]
        self._lrow = scene_info[&#39;lrow&#39;]
        self._date = scene_info[&#39;date&#39;]

        # Get the folder where this will be stored from the cache manager
        name = &#39;_&#39;.join([self._sensor, self._lpath, self._lrow, self._date])
        untar_folder = config.cache_manager().register_item(name)

        # Check if we already unpacked this data
        all_files_present = False
        if os.path.exists(untar_folder):
            mtl_path = _find_mtl_file(untar_folder)
            if mtl_path:
                mtl_data = _parse_mtl_file(mtl_path)
                all_files_present = _check_if_files_present(mtl_data, untar_folder)

        if all_files_present:
            print(&#39;Already have unpacked files in &#39; + untar_folder)
        else:
            print(&#39;Unpacking tar file &#39; + paths + &#39; to folder &#39; + untar_folder)
            utilities.unpack_to_folder(paths, untar_folder)

        bands_to_use = _get_landsat_bands_to_use(self._sensor)

        # Generate all the band file names (the MTL file is not returned)
        self._mtl_path = _find_mtl_file(untar_folder)
        self._mtl_data = _parse_mtl_file(self._mtl_path)
        output_paths = _get_band_paths(self._mtl_data, untar_folder, bands_to_use)

        # Check that the files exist
        for p in output_paths:
            if not os.path.exists(p):
                raise Exception(&#39;Did not find expected file: &#39; + p
                                + &#39; after unpacking tar file &#39; + paths)

        return output_paths

    def radiance_mult(self):
        return self._mtl_data[&#39;RADIANCE_MULT&#39;]
    def radiance_add(self):
        return self._mtl_data[&#39;RADIANCE_ADD&#39;]
    def reflectance_mult(self):
        return self._mtl_data[&#39;REFLECTANCE_MULT&#39;]
    def reflectance_add(self):
        return self._mtl_data[&#39;REFLECTANCE_ADD&#39;]
    def k1_constant(self):
        return self._mtl_data[&#39;K1_CONSTANT&#39;]
    def k2_constant(self):
        return self._mtl_data[&#39;K2_CONSTANT&#39;]
    def sun_elevation(self):
        return self._mtl_data[&#39;SUN_ELEVATION&#39;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="delta.imagery.sources.tiff.TiffImage" href="tiff.html#delta.imagery.sources.tiff.TiffImage">TiffImage</a></li>
<li><a title="delta.imagery.sources.delta_image.DeltaImage" href="delta_image.html#delta.imagery.sources.delta_image.DeltaImage">DeltaImage</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="delta.imagery.sources.landsat.LandsatImage.k1_constant"><code class="name flex">
<span>def <span class="ident">k1_constant</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def k1_constant(self):
    return self._mtl_data[&#39;K1_CONSTANT&#39;]</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.landsat.LandsatImage.k2_constant"><code class="name flex">
<span>def <span class="ident">k2_constant</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def k2_constant(self):
    return self._mtl_data[&#39;K2_CONSTANT&#39;]</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.landsat.LandsatImage.radiance_add"><code class="name flex">
<span>def <span class="ident">radiance_add</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def radiance_add(self):
    return self._mtl_data[&#39;RADIANCE_ADD&#39;]</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.landsat.LandsatImage.radiance_mult"><code class="name flex">
<span>def <span class="ident">radiance_mult</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def radiance_mult(self):
    return self._mtl_data[&#39;RADIANCE_MULT&#39;]</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.landsat.LandsatImage.reflectance_add"><code class="name flex">
<span>def <span class="ident">reflectance_add</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reflectance_add(self):
    return self._mtl_data[&#39;REFLECTANCE_ADD&#39;]</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.landsat.LandsatImage.reflectance_mult"><code class="name flex">
<span>def <span class="ident">reflectance_mult</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reflectance_mult(self):
    return self._mtl_data[&#39;REFLECTANCE_MULT&#39;]</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.landsat.LandsatImage.sun_elevation"><code class="name flex">
<span>def <span class="ident">sun_elevation</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sun_elevation(self):
    return self._mtl_data[&#39;SUN_ELEVATION&#39;]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="delta.imagery.sources.tiff.TiffImage" href="tiff.html#delta.imagery.sources.tiff.TiffImage">TiffImage</a></b></code>:
<ul class="hlist">
<li><code><a title="delta.imagery.sources.tiff.TiffImage.block_aligned_roi" href="tiff.html#delta.imagery.sources.tiff.TiffImage.block_aligned_roi">block_aligned_roi</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.block_info" href="tiff.html#delta.imagery.sources.tiff.TiffImage.block_info">block_info</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.bytes_per_pixel" href="tiff.html#delta.imagery.sources.tiff.TiffImage.bytes_per_pixel">bytes_per_pixel</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.data_type" href="tiff.html#delta.imagery.sources.tiff.TiffImage.data_type">data_type</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.height" href="delta_image.html#delta.imagery.sources.delta_image.DeltaImage.height">height</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.metadata" href="tiff.html#delta.imagery.sources.tiff.TiffImage.metadata">metadata</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.nodata_value" href="tiff.html#delta.imagery.sources.tiff.TiffImage.nodata_value">nodata_value</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.num_bands" href="delta_image.html#delta.imagery.sources.delta_image.DeltaImage.num_bands">num_bands</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.process_rois" href="delta_image.html#delta.imagery.sources.delta_image.DeltaImage.process_rois">process_rois</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.read" href="delta_image.html#delta.imagery.sources.delta_image.DeltaImage.read">read</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.roi_generator" href="delta_image.html#delta.imagery.sources.delta_image.DeltaImage.roi_generator">roi_generator</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.save" href="tiff.html#delta.imagery.sources.tiff.TiffImage.save">save</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.set_preprocess" href="delta_image.html#delta.imagery.sources.delta_image.DeltaImage.set_preprocess">set_preprocess</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.size" href="delta_image.html#delta.imagery.sources.delta_image.DeltaImage.size">size</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.tiles" href="delta_image.html#delta.imagery.sources.delta_image.DeltaImage.tiles">tiles</a></code></li>
<li><code><a title="delta.imagery.sources.tiff.TiffImage.width" href="delta_image.html#delta.imagery.sources.delta_image.DeltaImage.width">width</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="delta.imagery.sources" href="index.html">delta.imagery.sources</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="delta.imagery.sources.landsat.get_scene_info" href="#delta.imagery.sources.landsat.get_scene_info">get_scene_info</a></code></li>
<li><code><a title="delta.imagery.sources.landsat.toa_preprocess" href="#delta.imagery.sources.landsat.toa_preprocess">toa_preprocess</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="delta.imagery.sources.landsat.LandsatImage" href="#delta.imagery.sources.landsat.LandsatImage">LandsatImage</a></code></h4>
<ul class="two-column">
<li><code><a title="delta.imagery.sources.landsat.LandsatImage.k1_constant" href="#delta.imagery.sources.landsat.LandsatImage.k1_constant">k1_constant</a></code></li>
<li><code><a title="delta.imagery.sources.landsat.LandsatImage.k2_constant" href="#delta.imagery.sources.landsat.LandsatImage.k2_constant">k2_constant</a></code></li>
<li><code><a title="delta.imagery.sources.landsat.LandsatImage.radiance_add" href="#delta.imagery.sources.landsat.LandsatImage.radiance_add">radiance_add</a></code></li>
<li><code><a title="delta.imagery.sources.landsat.LandsatImage.radiance_mult" href="#delta.imagery.sources.landsat.LandsatImage.radiance_mult">radiance_mult</a></code></li>
<li><code><a title="delta.imagery.sources.landsat.LandsatImage.reflectance_add" href="#delta.imagery.sources.landsat.LandsatImage.reflectance_add">reflectance_add</a></code></li>
<li><code><a title="delta.imagery.sources.landsat.LandsatImage.reflectance_mult" href="#delta.imagery.sources.landsat.LandsatImage.reflectance_mult">reflectance_mult</a></code></li>
<li><code><a title="delta.imagery.sources.landsat.LandsatImage.sun_elevation" href="#delta.imagery.sources.landsat.LandsatImage.sun_elevation">sun_elevation</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>