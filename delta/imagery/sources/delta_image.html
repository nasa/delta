<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>delta.imagery.sources.delta_image API documentation</title>
<meta name="description" content="Base class for loading images." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>delta.imagery.sources.delta_image</code></h1>
</header>
<section id="section-intro">
<p>Base class for loading images.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright © 2020, United States Government, as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All rights reserved.
#
# The DELTA (Deep Earth Learning, Tools, and Analysis) platform is
# licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;
Base class for loading images.
&#34;&#34;&#34;

from abc import ABC, abstractmethod
import concurrent.futures
import copy
import functools
from typing import Callable, Iterator, List, Tuple

import numpy as np

from delta.imagery import rectangle, utilities

class DeltaImage(ABC):
    &#34;&#34;&#34;
    Base class used for wrapping input images in a way that they can be passed
    to Tensorflow dataset objects.
    &#34;&#34;&#34;
    def __init__(self):
        self.__preprocess_function = None

    def read(self, roi: rectangle.Rectangle=None, bands: List[int]=None, buf: np.ndarray=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Reads the image in [row, col, band] indexing.

        If `roi` is not specified, reads the entire image.
        If `buf` is specified, writes the image to buf.
        If `bands` is not specified, reads all bands, otherwise
        only the listed bands are read.
        If bands is a single integer, drops the band dimension.
        &#34;&#34;&#34;
        if roi is None:
            roi = rectangle.Rectangle(0, 0, width=self.width(), height=self.height())
        else:
            if roi.min_x &lt; 0 or roi.min_y &lt; 0 or roi.max_x &gt; self.width() or roi.max_y &gt; self.height():
                raise IndexError(&#39;Rectangle (%d, %d, %d, %d) outside of bounds (%d, %d).&#39; %
                                 (roi.min_x, roi.min_y, roi.max_x, roi.max_y, self.width(), self.height()))
        if bands is None:
            bands = range(self.num_bands())
        if isinstance(bands, int):
            result = self._read(roi, [bands], buf)
            result = result[:, :, 0] # reduce dimensions
        else:
            result = self._read(roi, bands, buf)
        if self.__preprocess_function:
            return self.__preprocess_function(result, roi, bands)
        return result

    def set_preprocess(self, callback: Callable[[np.ndarray, rectangle.Rectangle, List[int]], np.ndarray]) -&gt; None:
        &#34;&#34;&#34;
        Set a preproprocessing function callback to be applied to the results of all reads on the image.

        The function takes the arguments callback(image, roi, bands), where image is the numpy array containing
        the read data, roi is the region of interest read, and bands is a list of the bands being read.
        &#34;&#34;&#34;
        self.__preprocess_function = callback

    @abstractmethod
    def _read(self, roi, bands, buf=None):
        &#34;&#34;&#34;
        Read the image of the given data type. An optional roi specifies the boundaries.

        This function is intended to be overwritten by subclasses.
        &#34;&#34;&#34;

    def metadata(self): #pylint:disable=no-self-use
        &#34;&#34;&#34;
        Returns a dictionary of metadata, in the format used by GDAL.
        &#34;&#34;&#34;
        return {}

    @abstractmethod
    def size(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Return the size of this image in pixels, as (width, height).&#34;&#34;&#34;

    @abstractmethod
    def num_bands(self) -&gt; int:
        &#34;&#34;&#34;Return the number of bands in the image.&#34;&#34;&#34;

    def block_aligned_roi(self, desired_roi: rectangle.Rectangle) -&gt; rectangle.Rectangle:#pylint:disable=no-self-use
        &#34;&#34;&#34;Return the block-aligned roi containing this image region, if applicable.&#34;&#34;&#34;
        return desired_roi

    def width(self) -&gt; int:
        &#34;&#34;&#34;Return the number of columns.&#34;&#34;&#34;
        return self.size()[0]

    def height(self) -&gt; int:
        &#34;&#34;&#34;Return the number of rows.&#34;&#34;&#34;
        return self.size()[1]

    def tiles(self, width: int, height: int, min_width: int=0, min_height: int=0,
              overlap: int=0) -&gt; Iterator[rectangle.Rectangle]:
        &#34;&#34;&#34;Generator to yield ROIs for the image.&#34;&#34;&#34;
        input_bounds = rectangle.Rectangle(0, 0, width=self.width(), height=self.height())
        return input_bounds.make_tile_rois(width, height, min_width=min_width, min_height=min_height,
                                           include_partials=True, overlap_amount=overlap)

    def roi_generator(self, requested_rois: Iterator[rectangle.Rectangle]) -&gt; Iterator[rectangle.Rectangle]:
        &#34;&#34;&#34;
        Generator that yields ROIs of blocks in the requested region.
        &#34;&#34;&#34;
        block_rois = copy.copy(requested_rois)

        whole_bounds = rectangle.Rectangle(0, 0, width=self.width(), height=self.height())
        for roi in requested_rois:
            if not whole_bounds.contains_rect(roi):
                raise Exception(&#39;Roi outside image bounds: &#39; + str(roi) + str(whole_bounds))

        # gdal doesn&#39;t work reading multithreading. But this let&#39;s a thread
        # take care of IO input while we do computation.
        jobs = []

        total_rois = len(block_rois)
        while block_rois:
            # For the next (output) block, figure out the (input block) aligned
            # data read that we need to perform to get it.
            read_roi = self.block_aligned_roi(block_rois[0])

            applicable_rois = []

            # Loop through the remaining ROIs and apply the callback function to each
            # ROI that is contained in the section we read in.
            index = 0
            while index &lt; len(block_rois):

                if not read_roi.contains_rect(block_rois[index]):
                    index += 1
                    continue
                applicable_rois.append(block_rois.pop(index))

            jobs.append((read_roi, applicable_rois))

        # only do a few reads ahead since otherwise we will exhaust our memory
        pending = []
        exe = concurrent.futures.ThreadPoolExecutor(1)
        NUM_AHEAD = 2
        for i in range(min(NUM_AHEAD, len(jobs))):
            pending.append(exe.submit(functools.partial(self.read, jobs[i][0])))
        num_remaining = total_rois
        for (i, (read_roi, rois)) in enumerate(jobs):
            buf = pending.pop(0).result()
            for roi in rois:
                x0 = roi.min_x - read_roi.min_x
                y0 = roi.min_y - read_roi.min_y
                num_remaining -= 1
                yield (roi, buf[x0:x0 + roi.width(), y0:y0 + roi.height(), :],
                       (total_rois - num_remaining, total_rois))
            if i + NUM_AHEAD &lt; len(jobs):
                pending.append(exe.submit(functools.partial(self.read, jobs[i + NUM_AHEAD][0])))

    def process_rois(self, requested_rois: Iterator[rectangle.Rectangle],
                     callback_function: Callable[[rectangle.Rectangle, np.ndarray], None],
                     show_progress: bool=False) -&gt; None:
        &#34;&#34;&#34;
        Process the given region broken up into blocks using the callback function.
        Each block will get the image data from each input image passed into the function.
        Data reading takes place in a separate thread, but the callbacks are executed
        in a consistent order on a single thread.
        &#34;&#34;&#34;
        for (roi, buf, (i, total)) in self.roi_generator(requested_rois):
            callback_function(roi, buf)
            if show_progress:
                utilities.progress_bar(&#39;%d / %d&#39; % (i, total), i / total, prefix=&#39;Blocks Processed:&#39;)
        if show_progress:
            print()

class DeltaImageWriter(ABC):
    @abstractmethod
    def initialize(self, size, numpy_dtype, metadata=None):
        &#34;&#34;&#34;
        Prepare for writing with the given size and dtype.
        &#34;&#34;&#34;

    @abstractmethod
    def write(self, data, x, y):
        &#34;&#34;&#34;
        Writes the data as a rectangular block starting at the given coordinates.
        &#34;&#34;&#34;

    @abstractmethod
    def close(self):
        &#34;&#34;&#34;
        Finish writing.
        &#34;&#34;&#34;

    @abstractmethod
    def abort(self):
        &#34;&#34;&#34;
        Cancel writing before finished.
        &#34;&#34;&#34;

    def __del__(self):
        self.close()

    def __enter__(self):
        return self

    def __exit__(self, *unused):
        self.close()
        return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="delta.imagery.sources.delta_image.DeltaImage"><code class="flex name class">
<span>class <span class="ident">DeltaImage</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class used for wrapping input images in a way that they can be passed
to Tensorflow dataset objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeltaImage(ABC):
    &#34;&#34;&#34;
    Base class used for wrapping input images in a way that they can be passed
    to Tensorflow dataset objects.
    &#34;&#34;&#34;
    def __init__(self):
        self.__preprocess_function = None

    def read(self, roi: rectangle.Rectangle=None, bands: List[int]=None, buf: np.ndarray=None) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Reads the image in [row, col, band] indexing.

        If `roi` is not specified, reads the entire image.
        If `buf` is specified, writes the image to buf.
        If `bands` is not specified, reads all bands, otherwise
        only the listed bands are read.
        If bands is a single integer, drops the band dimension.
        &#34;&#34;&#34;
        if roi is None:
            roi = rectangle.Rectangle(0, 0, width=self.width(), height=self.height())
        else:
            if roi.min_x &lt; 0 or roi.min_y &lt; 0 or roi.max_x &gt; self.width() or roi.max_y &gt; self.height():
                raise IndexError(&#39;Rectangle (%d, %d, %d, %d) outside of bounds (%d, %d).&#39; %
                                 (roi.min_x, roi.min_y, roi.max_x, roi.max_y, self.width(), self.height()))
        if bands is None:
            bands = range(self.num_bands())
        if isinstance(bands, int):
            result = self._read(roi, [bands], buf)
            result = result[:, :, 0] # reduce dimensions
        else:
            result = self._read(roi, bands, buf)
        if self.__preprocess_function:
            return self.__preprocess_function(result, roi, bands)
        return result

    def set_preprocess(self, callback: Callable[[np.ndarray, rectangle.Rectangle, List[int]], np.ndarray]) -&gt; None:
        &#34;&#34;&#34;
        Set a preproprocessing function callback to be applied to the results of all reads on the image.

        The function takes the arguments callback(image, roi, bands), where image is the numpy array containing
        the read data, roi is the region of interest read, and bands is a list of the bands being read.
        &#34;&#34;&#34;
        self.__preprocess_function = callback

    @abstractmethod
    def _read(self, roi, bands, buf=None):
        &#34;&#34;&#34;
        Read the image of the given data type. An optional roi specifies the boundaries.

        This function is intended to be overwritten by subclasses.
        &#34;&#34;&#34;

    def metadata(self): #pylint:disable=no-self-use
        &#34;&#34;&#34;
        Returns a dictionary of metadata, in the format used by GDAL.
        &#34;&#34;&#34;
        return {}

    @abstractmethod
    def size(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;Return the size of this image in pixels, as (width, height).&#34;&#34;&#34;

    @abstractmethod
    def num_bands(self) -&gt; int:
        &#34;&#34;&#34;Return the number of bands in the image.&#34;&#34;&#34;

    def block_aligned_roi(self, desired_roi: rectangle.Rectangle) -&gt; rectangle.Rectangle:#pylint:disable=no-self-use
        &#34;&#34;&#34;Return the block-aligned roi containing this image region, if applicable.&#34;&#34;&#34;
        return desired_roi

    def width(self) -&gt; int:
        &#34;&#34;&#34;Return the number of columns.&#34;&#34;&#34;
        return self.size()[0]

    def height(self) -&gt; int:
        &#34;&#34;&#34;Return the number of rows.&#34;&#34;&#34;
        return self.size()[1]

    def tiles(self, width: int, height: int, min_width: int=0, min_height: int=0,
              overlap: int=0) -&gt; Iterator[rectangle.Rectangle]:
        &#34;&#34;&#34;Generator to yield ROIs for the image.&#34;&#34;&#34;
        input_bounds = rectangle.Rectangle(0, 0, width=self.width(), height=self.height())
        return input_bounds.make_tile_rois(width, height, min_width=min_width, min_height=min_height,
                                           include_partials=True, overlap_amount=overlap)

    def roi_generator(self, requested_rois: Iterator[rectangle.Rectangle]) -&gt; Iterator[rectangle.Rectangle]:
        &#34;&#34;&#34;
        Generator that yields ROIs of blocks in the requested region.
        &#34;&#34;&#34;
        block_rois = copy.copy(requested_rois)

        whole_bounds = rectangle.Rectangle(0, 0, width=self.width(), height=self.height())
        for roi in requested_rois:
            if not whole_bounds.contains_rect(roi):
                raise Exception(&#39;Roi outside image bounds: &#39; + str(roi) + str(whole_bounds))

        # gdal doesn&#39;t work reading multithreading. But this let&#39;s a thread
        # take care of IO input while we do computation.
        jobs = []

        total_rois = len(block_rois)
        while block_rois:
            # For the next (output) block, figure out the (input block) aligned
            # data read that we need to perform to get it.
            read_roi = self.block_aligned_roi(block_rois[0])

            applicable_rois = []

            # Loop through the remaining ROIs and apply the callback function to each
            # ROI that is contained in the section we read in.
            index = 0
            while index &lt; len(block_rois):

                if not read_roi.contains_rect(block_rois[index]):
                    index += 1
                    continue
                applicable_rois.append(block_rois.pop(index))

            jobs.append((read_roi, applicable_rois))

        # only do a few reads ahead since otherwise we will exhaust our memory
        pending = []
        exe = concurrent.futures.ThreadPoolExecutor(1)
        NUM_AHEAD = 2
        for i in range(min(NUM_AHEAD, len(jobs))):
            pending.append(exe.submit(functools.partial(self.read, jobs[i][0])))
        num_remaining = total_rois
        for (i, (read_roi, rois)) in enumerate(jobs):
            buf = pending.pop(0).result()
            for roi in rois:
                x0 = roi.min_x - read_roi.min_x
                y0 = roi.min_y - read_roi.min_y
                num_remaining -= 1
                yield (roi, buf[x0:x0 + roi.width(), y0:y0 + roi.height(), :],
                       (total_rois - num_remaining, total_rois))
            if i + NUM_AHEAD &lt; len(jobs):
                pending.append(exe.submit(functools.partial(self.read, jobs[i + NUM_AHEAD][0])))

    def process_rois(self, requested_rois: Iterator[rectangle.Rectangle],
                     callback_function: Callable[[rectangle.Rectangle, np.ndarray], None],
                     show_progress: bool=False) -&gt; None:
        &#34;&#34;&#34;
        Process the given region broken up into blocks using the callback function.
        Each block will get the image data from each input image passed into the function.
        Data reading takes place in a separate thread, but the callbacks are executed
        in a consistent order on a single thread.
        &#34;&#34;&#34;
        for (roi, buf, (i, total)) in self.roi_generator(requested_rois):
            callback_function(roi, buf)
            if show_progress:
                utilities.progress_bar(&#39;%d / %d&#39; % (i, total), i / total, prefix=&#39;Blocks Processed:&#39;)
        if show_progress:
            print()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="delta.imagery.sources.npy.NumpyImage" href="npy.html#delta.imagery.sources.npy.NumpyImage">NumpyImage</a></li>
<li><a title="delta.imagery.sources.tiff.TiffImage" href="tiff.html#delta.imagery.sources.tiff.TiffImage">TiffImage</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="delta.imagery.sources.delta_image.DeltaImage.block_aligned_roi"><code class="name flex">
<span>def <span class="ident">block_aligned_roi</span></span>(<span>self, desired_roi: <a title="delta.imagery.rectangle.Rectangle" href="../rectangle.html#delta.imagery.rectangle.Rectangle">Rectangle</a>) ‑> <a title="delta.imagery.rectangle.Rectangle" href="../rectangle.html#delta.imagery.rectangle.Rectangle">Rectangle</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return the block-aligned roi containing this image region, if applicable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def block_aligned_roi(self, desired_roi: rectangle.Rectangle) -&gt; rectangle.Rectangle:#pylint:disable=no-self-use
    &#34;&#34;&#34;Return the block-aligned roi containing this image region, if applicable.&#34;&#34;&#34;
    return desired_roi</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImage.height"><code class="name flex">
<span>def <span class="ident">height</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Return the number of rows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def height(self) -&gt; int:
    &#34;&#34;&#34;Return the number of rows.&#34;&#34;&#34;
    return self.size()[1]</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImage.metadata"><code class="name flex">
<span>def <span class="ident">metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary of metadata, in the format used by GDAL.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metadata(self): #pylint:disable=no-self-use
    &#34;&#34;&#34;
    Returns a dictionary of metadata, in the format used by GDAL.
    &#34;&#34;&#34;
    return {}</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImage.num_bands"><code class="name flex">
<span>def <span class="ident">num_bands</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Return the number of bands in the image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def num_bands(self) -&gt; int:
    &#34;&#34;&#34;Return the number of bands in the image.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImage.process_rois"><code class="name flex">
<span>def <span class="ident">process_rois</span></span>(<span>self, requested_rois: Iterator[<a title="delta.imagery.rectangle.Rectangle" href="../rectangle.html#delta.imagery.rectangle.Rectangle">Rectangle</a>], callback_function: Callable[[<a title="delta.imagery.rectangle.Rectangle" href="../rectangle.html#delta.imagery.rectangle.Rectangle">Rectangle</a>, numpy.ndarray], NoneType], show_progress: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Process the given region broken up into blocks using the callback function.
Each block will get the image data from each input image passed into the function.
Data reading takes place in a separate thread, but the callbacks are executed
in a consistent order on a single thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_rois(self, requested_rois: Iterator[rectangle.Rectangle],
                 callback_function: Callable[[rectangle.Rectangle, np.ndarray], None],
                 show_progress: bool=False) -&gt; None:
    &#34;&#34;&#34;
    Process the given region broken up into blocks using the callback function.
    Each block will get the image data from each input image passed into the function.
    Data reading takes place in a separate thread, but the callbacks are executed
    in a consistent order on a single thread.
    &#34;&#34;&#34;
    for (roi, buf, (i, total)) in self.roi_generator(requested_rois):
        callback_function(roi, buf)
        if show_progress:
            utilities.progress_bar(&#39;%d / %d&#39; % (i, total), i / total, prefix=&#39;Blocks Processed:&#39;)
    if show_progress:
        print()</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImage.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, roi: <a title="delta.imagery.rectangle.Rectangle" href="../rectangle.html#delta.imagery.rectangle.Rectangle">Rectangle</a> = None, bands: List[int] = None, buf: numpy.ndarray = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the image in [row, col, band] indexing.</p>
<p>If <code>roi</code> is not specified, reads the entire image.
If <code>buf</code> is specified, writes the image to buf.
If <code>bands</code> is not specified, reads all bands, otherwise
only the listed bands are read.
If bands is a single integer, drops the band dimension.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, roi: rectangle.Rectangle=None, bands: List[int]=None, buf: np.ndarray=None) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Reads the image in [row, col, band] indexing.

    If `roi` is not specified, reads the entire image.
    If `buf` is specified, writes the image to buf.
    If `bands` is not specified, reads all bands, otherwise
    only the listed bands are read.
    If bands is a single integer, drops the band dimension.
    &#34;&#34;&#34;
    if roi is None:
        roi = rectangle.Rectangle(0, 0, width=self.width(), height=self.height())
    else:
        if roi.min_x &lt; 0 or roi.min_y &lt; 0 or roi.max_x &gt; self.width() or roi.max_y &gt; self.height():
            raise IndexError(&#39;Rectangle (%d, %d, %d, %d) outside of bounds (%d, %d).&#39; %
                             (roi.min_x, roi.min_y, roi.max_x, roi.max_y, self.width(), self.height()))
    if bands is None:
        bands = range(self.num_bands())
    if isinstance(bands, int):
        result = self._read(roi, [bands], buf)
        result = result[:, :, 0] # reduce dimensions
    else:
        result = self._read(roi, bands, buf)
    if self.__preprocess_function:
        return self.__preprocess_function(result, roi, bands)
    return result</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImage.roi_generator"><code class="name flex">
<span>def <span class="ident">roi_generator</span></span>(<span>self, requested_rois: Iterator[<a title="delta.imagery.rectangle.Rectangle" href="../rectangle.html#delta.imagery.rectangle.Rectangle">Rectangle</a>]) ‑> Iterator[<a title="delta.imagery.rectangle.Rectangle" href="../rectangle.html#delta.imagery.rectangle.Rectangle">Rectangle</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Generator that yields ROIs of blocks in the requested region.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def roi_generator(self, requested_rois: Iterator[rectangle.Rectangle]) -&gt; Iterator[rectangle.Rectangle]:
    &#34;&#34;&#34;
    Generator that yields ROIs of blocks in the requested region.
    &#34;&#34;&#34;
    block_rois = copy.copy(requested_rois)

    whole_bounds = rectangle.Rectangle(0, 0, width=self.width(), height=self.height())
    for roi in requested_rois:
        if not whole_bounds.contains_rect(roi):
            raise Exception(&#39;Roi outside image bounds: &#39; + str(roi) + str(whole_bounds))

    # gdal doesn&#39;t work reading multithreading. But this let&#39;s a thread
    # take care of IO input while we do computation.
    jobs = []

    total_rois = len(block_rois)
    while block_rois:
        # For the next (output) block, figure out the (input block) aligned
        # data read that we need to perform to get it.
        read_roi = self.block_aligned_roi(block_rois[0])

        applicable_rois = []

        # Loop through the remaining ROIs and apply the callback function to each
        # ROI that is contained in the section we read in.
        index = 0
        while index &lt; len(block_rois):

            if not read_roi.contains_rect(block_rois[index]):
                index += 1
                continue
            applicable_rois.append(block_rois.pop(index))

        jobs.append((read_roi, applicable_rois))

    # only do a few reads ahead since otherwise we will exhaust our memory
    pending = []
    exe = concurrent.futures.ThreadPoolExecutor(1)
    NUM_AHEAD = 2
    for i in range(min(NUM_AHEAD, len(jobs))):
        pending.append(exe.submit(functools.partial(self.read, jobs[i][0])))
    num_remaining = total_rois
    for (i, (read_roi, rois)) in enumerate(jobs):
        buf = pending.pop(0).result()
        for roi in rois:
            x0 = roi.min_x - read_roi.min_x
            y0 = roi.min_y - read_roi.min_y
            num_remaining -= 1
            yield (roi, buf[x0:x0 + roi.width(), y0:y0 + roi.height(), :],
                   (total_rois - num_remaining, total_rois))
        if i + NUM_AHEAD &lt; len(jobs):
            pending.append(exe.submit(functools.partial(self.read, jobs[i + NUM_AHEAD][0])))</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImage.set_preprocess"><code class="name flex">
<span>def <span class="ident">set_preprocess</span></span>(<span>self, callback: Callable[[numpy.ndarray, <a title="delta.imagery.rectangle.Rectangle" href="../rectangle.html#delta.imagery.rectangle.Rectangle">Rectangle</a>, List[int]], numpy.ndarray]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set a preproprocessing function callback to be applied to the results of all reads on the image.</p>
<p>The function takes the arguments callback(image, roi, bands), where image is the numpy array containing
the read data, roi is the region of interest read, and bands is a list of the bands being read.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_preprocess(self, callback: Callable[[np.ndarray, rectangle.Rectangle, List[int]], np.ndarray]) -&gt; None:
    &#34;&#34;&#34;
    Set a preproprocessing function callback to be applied to the results of all reads on the image.

    The function takes the arguments callback(image, roi, bands), where image is the numpy array containing
    the read data, roi is the region of interest read, and bands is a list of the bands being read.
    &#34;&#34;&#34;
    self.__preprocess_function = callback</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImage.size"><code class="name flex">
<span>def <span class="ident">size</span></span>(<span>self) ‑> Tuple[int, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the size of this image in pixels, as (width, height).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def size(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Return the size of this image in pixels, as (width, height).&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImage.tiles"><code class="name flex">
<span>def <span class="ident">tiles</span></span>(<span>self, width: int, height: int, min_width: int = 0, min_height: int = 0, overlap: int = 0) ‑> Iterator[<a title="delta.imagery.rectangle.Rectangle" href="../rectangle.html#delta.imagery.rectangle.Rectangle">Rectangle</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Generator to yield ROIs for the image.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tiles(self, width: int, height: int, min_width: int=0, min_height: int=0,
          overlap: int=0) -&gt; Iterator[rectangle.Rectangle]:
    &#34;&#34;&#34;Generator to yield ROIs for the image.&#34;&#34;&#34;
    input_bounds = rectangle.Rectangle(0, 0, width=self.width(), height=self.height())
    return input_bounds.make_tile_rois(width, height, min_width=min_width, min_height=min_height,
                                       include_partials=True, overlap_amount=overlap)</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImage.width"><code class="name flex">
<span>def <span class="ident">width</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Return the number of columns.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def width(self) -&gt; int:
    &#34;&#34;&#34;Return the number of columns.&#34;&#34;&#34;
    return self.size()[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImageWriter"><code class="flex name class">
<span>class <span class="ident">DeltaImageWriter</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeltaImageWriter(ABC):
    @abstractmethod
    def initialize(self, size, numpy_dtype, metadata=None):
        &#34;&#34;&#34;
        Prepare for writing with the given size and dtype.
        &#34;&#34;&#34;

    @abstractmethod
    def write(self, data, x, y):
        &#34;&#34;&#34;
        Writes the data as a rectangular block starting at the given coordinates.
        &#34;&#34;&#34;

    @abstractmethod
    def close(self):
        &#34;&#34;&#34;
        Finish writing.
        &#34;&#34;&#34;

    @abstractmethod
    def abort(self):
        &#34;&#34;&#34;
        Cancel writing before finished.
        &#34;&#34;&#34;

    def __del__(self):
        self.close()

    def __enter__(self):
        return self

    def __exit__(self, *unused):
        self.close()
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="delta.imagery.sources.npy.NumpyImageWriter" href="npy.html#delta.imagery.sources.npy.NumpyImageWriter">NumpyImageWriter</a></li>
<li><a title="delta.imagery.sources.tiff.DeltaTiffWriter" href="tiff.html#delta.imagery.sources.tiff.DeltaTiffWriter">DeltaTiffWriter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="delta.imagery.sources.delta_image.DeltaImageWriter.abort"><code class="name flex">
<span>def <span class="ident">abort</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Cancel writing before finished.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def abort(self):
    &#34;&#34;&#34;
    Cancel writing before finished.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImageWriter.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Finish writing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def close(self):
    &#34;&#34;&#34;
    Finish writing.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImageWriter.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self, size, numpy_dtype, metadata=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare for writing with the given size and dtype.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def initialize(self, size, numpy_dtype, metadata=None):
    &#34;&#34;&#34;
    Prepare for writing with the given size and dtype.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="delta.imagery.sources.delta_image.DeltaImageWriter.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, data, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the data as a rectangular block starting at the given coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def write(self, data, x, y):
    &#34;&#34;&#34;
    Writes the data as a rectangular block starting at the given coordinates.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="delta.imagery.sources" href="index.html">delta.imagery.sources</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="delta.imagery.sources.delta_image.DeltaImage" href="#delta.imagery.sources.delta_image.DeltaImage">DeltaImage</a></code></h4>
<ul class="two-column">
<li><code><a title="delta.imagery.sources.delta_image.DeltaImage.block_aligned_roi" href="#delta.imagery.sources.delta_image.DeltaImage.block_aligned_roi">block_aligned_roi</a></code></li>
<li><code><a title="delta.imagery.sources.delta_image.DeltaImage.height" href="#delta.imagery.sources.delta_image.DeltaImage.height">height</a></code></li>
<li><code><a title="delta.imagery.sources.delta_image.DeltaImage.metadata" href="#delta.imagery.sources.delta_image.DeltaImage.metadata">metadata</a></code></li>
<li><code><a title="delta.imagery.sources.delta_image.DeltaImage.num_bands" href="#delta.imagery.sources.delta_image.DeltaImage.num_bands">num_bands</a></code></li>
<li><code><a title="delta.imagery.sources.delta_image.DeltaImage.process_rois" href="#delta.imagery.sources.delta_image.DeltaImage.process_rois">process_rois</a></code></li>
<li><code><a title="delta.imagery.sources.delta_image.DeltaImage.read" href="#delta.imagery.sources.delta_image.DeltaImage.read">read</a></code></li>
<li><code><a title="delta.imagery.sources.delta_image.DeltaImage.roi_generator" href="#delta.imagery.sources.delta_image.DeltaImage.roi_generator">roi_generator</a></code></li>
<li><code><a title="delta.imagery.sources.delta_image.DeltaImage.set_preprocess" href="#delta.imagery.sources.delta_image.DeltaImage.set_preprocess">set_preprocess</a></code></li>
<li><code><a title="delta.imagery.sources.delta_image.DeltaImage.size" href="#delta.imagery.sources.delta_image.DeltaImage.size">size</a></code></li>
<li><code><a title="delta.imagery.sources.delta_image.DeltaImage.tiles" href="#delta.imagery.sources.delta_image.DeltaImage.tiles">tiles</a></code></li>
<li><code><a title="delta.imagery.sources.delta_image.DeltaImage.width" href="#delta.imagery.sources.delta_image.DeltaImage.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="delta.imagery.sources.delta_image.DeltaImageWriter" href="#delta.imagery.sources.delta_image.DeltaImageWriter">DeltaImageWriter</a></code></h4>
<ul class="">
<li><code><a title="delta.imagery.sources.delta_image.DeltaImageWriter.abort" href="#delta.imagery.sources.delta_image.DeltaImageWriter.abort">abort</a></code></li>
<li><code><a title="delta.imagery.sources.delta_image.DeltaImageWriter.close" href="#delta.imagery.sources.delta_image.DeltaImageWriter.close">close</a></code></li>
<li><code><a title="delta.imagery.sources.delta_image.DeltaImageWriter.initialize" href="#delta.imagery.sources.delta_image.DeltaImageWriter.initialize">initialize</a></code></li>
<li><code><a title="delta.imagery.sources.delta_image.DeltaImageWriter.write" href="#delta.imagery.sources.delta_image.DeltaImageWriter.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>