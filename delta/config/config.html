<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>delta.config.config API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>delta.config.config</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright © 2020, United States Government, as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All rights reserved.
#
# The DELTA (Deep Earth Learning, Tools, and Analysis) platform is
# licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os.path

import yaml
import pkg_resources
import appdirs

def validate_path(path, base_dir):
    if path == &#39;default&#39;:
        return path
    path = os.path.expanduser(path)
    # make relative paths relative to this config file
    if base_dir:
        path = os.path.normpath(os.path.join(base_dir, path))
    return path

def validate_positive(num, _):
    if num &lt;= 0:
        raise ValueError(&#39;%d is not positive&#39; % (num))
    return num

class _NotSpecified: #pylint:disable=too-few-public-methods
    pass

class DeltaConfigComponent:
    &#34;&#34;&#34;
    DELTA configuration component.

    Handles one subsection of a config file. Generally subclasses
    will want to register fields and components in the constructor,
    and possibly override setup_arg_parser and parse_args to handle
    command line options.

    section_header is the title of the section for command line
    arguments in the help.
    &#34;&#34;&#34;
    def __init__(self, section_header = None):
        &#34;&#34;&#34;
        Constructs the component.
        &#34;&#34;&#34;
        self._config_dict = {}
        self._components = {}
        self._fields = []
        self._validate = {}
        self._types = {}
        self._cmd_args = {}
        self._descs = {}
        self._section_header = section_header

    def reset(self):
        &#34;&#34;&#34;
        Resets all state in the component.
        &#34;&#34;&#34;
        self._config_dict = {}
        for c in self._components.values():
            c.reset()

    def register_component(self, component, name : str, attr_name = None):
        &#34;&#34;&#34;
        Register a subcomponent with a name and attribute name (access as self.attr_name)
        &#34;&#34;&#34;
        assert name not in self._components
        self._components[name] = component
        if attr_name is None:
            attr_name = name
        setattr(self, attr_name, component)

    def register_field(self, name : str, types, accessor = None, validate_fn = None, desc = None):
        &#34;&#34;&#34;
        Register a field in this component of the configuration.

        types is a single type or a tuple of valid types

        validate_fn (optional) should take two strings as input, the field&#39;s value and
        the base directory, and return what to save to the config dictionary.
        It should raise an exception if the field is invalid.
        accessor is an optional name to create an accessor function with
        &#34;&#34;&#34;
        self._fields.append(name)
        self._validate[name] = validate_fn
        self._types[name] = types
        self._descs[name] = desc
        if accessor:
            def access(self) -&gt; types:
                return self._config_dict[name]#pylint:disable=protected-access
            access.__name__ = accessor
            access.__doc__ = desc
            setattr(self.__class__, accessor, access)

    def register_arg(self, field, argname, **kwargs):
        &#34;&#34;&#34;
        Registers a command line argument in this component.

        field is the (registered) field this argument modifies.
        argname is the name of the flag on the command line (i.e., &#39;--flag&#39;)
        **kwargs are arguments to ArgumentParser.add_argument.

        If help and type are not specified, will use the ones for the field.
        If default is not specified, will use the value from the config files.
        &#34;&#34;&#34;
        assert field in self._fields, &#39;Field %s not registered.&#39; % (field)
        if &#39;help&#39; not in kwargs:
            kwargs[&#39;help&#39;] = self._descs[field]
        if &#39;type&#39; not in kwargs:
            kwargs[&#39;type&#39;] = self._types[field]
        elif kwargs[&#39;type&#39;] is None:
            del kwargs[&#39;type&#39;]
        if &#39;default&#39; not in kwargs:
            kwargs[&#39;default&#39;] = _NotSpecified
        self._cmd_args[argname] = (field, kwargs)

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        Returns a dictionary representing the config object.
        &#34;&#34;&#34;
        if isinstance(self._config_dict, dict):
            exp = self._config_dict.copy()
            for (name, c) in self._components.items():
                exp[name] = c.to_dict()
            return exp
        return self._config_dict

    def export(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a YAML string of all configuration options, from to_dict.
        &#34;&#34;&#34;
        return yaml.dump(self.to_dict())

    def _set_field(self, name : str, value : str, base_dir : str):
        if name not in self._fields:
            raise ValueError(&#39;Unexpected field %s in config file.&#39; % (name))
        if value is not None and not isinstance(value, self._types[name]):
            raise TypeError(&#39;%s must be of type %s, is %s.&#39; % (name, self._types[name], value))
        if self._validate[name] and value is not None:
            try:
                value = self._validate[name](value, base_dir)
            except:
                print(&#39;Value %s for %s is invalid.&#39; % (value, name))
                raise
        self._config_dict[name] = value

    def _load_dict(self, d : dict, base_dir):
        &#34;&#34;&#34;
        Loads the dictionary d, assuming it came from the given base_dir (for relative paths).
        &#34;&#34;&#34;
        for (k, v) in d.items():
            if k in self._components:
                self._components[k]._load_dict(v, base_dir) #pylint:disable=protected-access
            else:
                self._set_field(k, v, base_dir)

    def setup_arg_parser(self, parser, components = None) -&gt; None:
        &#34;&#34;&#34;
        Adds arguments to the parser. Must overridden by child classes.
        &#34;&#34;&#34;
        if self._section_header is not None:
            parser = parser.add_argument_group(self._section_header)
        for (arg, value) in self._cmd_args.items():
            (field, kwargs) = value
            parser.add_argument(arg, dest=field, **kwargs)

        for (name, c) in self._components.items():
            if components is None or name in components:
                c.setup_arg_parser(parser)

    def parse_args(self, options):
        &#34;&#34;&#34;
        Parse options extracted from an ArgParser configured with
        `setup_arg_parser` and override the appropriate
        configuration values.
        &#34;&#34;&#34;
        d = {}
        for (field, _) in self._cmd_args.values():
            if not hasattr(options, field) or getattr(options, field) is None:
                continue
            if getattr(options, field) is _NotSpecified:
                continue
            d[field] = getattr(options, field)
        self._load_dict(d, None)

        for c in self._components.values():
            c.parse_args(options)

class DeltaConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    DELTA configuration manager.

    Access and control all configuration parameters.
    &#34;&#34;&#34;
    def load(self, yaml_file: str = None, yaml_str: str = None):
        &#34;&#34;&#34;
        Loads a config file, then updates the default configuration
        with the loaded values.
        &#34;&#34;&#34;
        base_path = None
        if yaml_file:
            #print(&#34;Loading config file: &#34; + yaml_file)
            if not os.path.exists(yaml_file):
                raise Exception(&#39;Config file does not exist: &#39; + yaml_file)
            with open(yaml_file, &#39;r&#39;) as f:
                config_data = yaml.safe_load(f)
            base_path = os.path.normpath(os.path.dirname(yaml_file))
        else:
            config_data = yaml.safe_load(yaml_str)
        self._load_dict(config_data, base_path)

    def setup_arg_parser(self, parser, components=None) -&gt; None:
        parser.add_argument(&#39;--config&#39;, dest=&#39;config&#39;, action=&#39;append&#39;, required=False, default=[],
                            help=&#39;Load configuration file (can pass multiple times).&#39;)
        super().setup_arg_parser(parser, components)

    def parse_args(self, options):
        for c in options.config:
            self.load(c)
        super().parse_args(options)

    def reset(self):
        super().reset()
        self.load(pkg_resources.resource_filename(&#39;delta&#39;, &#39;config/delta.yaml&#39;))

    def initialize(self, options, config_files = None):
        &#34;&#34;&#34;
        Loads the default files unless config_files is specified, in which case it
        loads them. Then loads options (from argparse).
        &#34;&#34;&#34;
        self.reset()

        if config_files is None:
            dirs = appdirs.AppDirs(&#39;delta&#39;, &#39;nasa&#39;)
            config_files = [os.path.join(dirs.site_config_dir, &#39;delta.yaml&#39;),
                            os.path.join(dirs.user_config_dir, &#39;delta.yaml&#39;)]

        for filename in config_files:
            if os.path.exists(filename):
                config.load(filename)

        if options is not None:
            config.parse_args(options)

config = DeltaConfig()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="delta.config.config.validate_path"><code class="name flex">
<span>def <span class="ident">validate_path</span></span>(<span>path, base_dir)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_path(path, base_dir):
    if path == &#39;default&#39;:
        return path
    path = os.path.expanduser(path)
    # make relative paths relative to this config file
    if base_dir:
        path = os.path.normpath(os.path.join(base_dir, path))
    return path</code></pre>
</details>
</dd>
<dt id="delta.config.config.validate_positive"><code class="name flex">
<span>def <span class="ident">validate_positive</span></span>(<span>num, _)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_positive(num, _):
    if num &lt;= 0:
        raise ValueError(&#39;%d is not positive&#39; % (num))
    return num</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="delta.config.config.DeltaConfig"><code class="flex name class">
<span>class <span class="ident">DeltaConfig</span></span>
<span>(</span><span>section_header=None)</span>
</code></dt>
<dd>
<div class="desc"><p>DELTA configuration manager.</p>
<p>Access and control all configuration parameters.</p>
<p>Constructs the component.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeltaConfig(DeltaConfigComponent):
    &#34;&#34;&#34;
    DELTA configuration manager.

    Access and control all configuration parameters.
    &#34;&#34;&#34;
    def load(self, yaml_file: str = None, yaml_str: str = None):
        &#34;&#34;&#34;
        Loads a config file, then updates the default configuration
        with the loaded values.
        &#34;&#34;&#34;
        base_path = None
        if yaml_file:
            #print(&#34;Loading config file: &#34; + yaml_file)
            if not os.path.exists(yaml_file):
                raise Exception(&#39;Config file does not exist: &#39; + yaml_file)
            with open(yaml_file, &#39;r&#39;) as f:
                config_data = yaml.safe_load(f)
            base_path = os.path.normpath(os.path.dirname(yaml_file))
        else:
            config_data = yaml.safe_load(yaml_str)
        self._load_dict(config_data, base_path)

    def setup_arg_parser(self, parser, components=None) -&gt; None:
        parser.add_argument(&#39;--config&#39;, dest=&#39;config&#39;, action=&#39;append&#39;, required=False, default=[],
                            help=&#39;Load configuration file (can pass multiple times).&#39;)
        super().setup_arg_parser(parser, components)

    def parse_args(self, options):
        for c in options.config:
            self.load(c)
        super().parse_args(options)

    def reset(self):
        super().reset()
        self.load(pkg_resources.resource_filename(&#39;delta&#39;, &#39;config/delta.yaml&#39;))

    def initialize(self, options, config_files = None):
        &#34;&#34;&#34;
        Loads the default files unless config_files is specified, in which case it
        loads them. Then loads options (from argparse).
        &#34;&#34;&#34;
        self.reset()

        if config_files is None:
            dirs = appdirs.AppDirs(&#39;delta&#39;, &#39;nasa&#39;)
            config_files = [os.path.join(dirs.site_config_dir, &#39;delta.yaml&#39;),
                            os.path.join(dirs.user_config_dir, &#39;delta.yaml&#39;)]

        for filename in config_files:
            if os.path.exists(filename):
                config.load(filename)

        if options is not None:
            config.parse_args(options)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="delta.config.config.DeltaConfigComponent" href="#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="delta.config.config.DeltaConfig.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self, options, config_files=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads the default files unless config_files is specified, in which case it
loads them. Then loads options (from argparse).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self, options, config_files = None):
    &#34;&#34;&#34;
    Loads the default files unless config_files is specified, in which case it
    loads them. Then loads options (from argparse).
    &#34;&#34;&#34;
    self.reset()

    if config_files is None:
        dirs = appdirs.AppDirs(&#39;delta&#39;, &#39;nasa&#39;)
        config_files = [os.path.join(dirs.site_config_dir, &#39;delta.yaml&#39;),
                        os.path.join(dirs.user_config_dir, &#39;delta.yaml&#39;)]

    for filename in config_files:
        if os.path.exists(filename):
            config.load(filename)

    if options is not None:
        config.parse_args(options)</code></pre>
</details>
</dd>
<dt id="delta.config.config.DeltaConfig.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, yaml_file: str = None, yaml_str: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a config file, then updates the default configuration
with the loaded values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load(self, yaml_file: str = None, yaml_str: str = None):
    &#34;&#34;&#34;
    Loads a config file, then updates the default configuration
    with the loaded values.
    &#34;&#34;&#34;
    base_path = None
    if yaml_file:
        #print(&#34;Loading config file: &#34; + yaml_file)
        if not os.path.exists(yaml_file):
            raise Exception(&#39;Config file does not exist: &#39; + yaml_file)
        with open(yaml_file, &#39;r&#39;) as f:
            config_data = yaml.safe_load(f)
        base_path = os.path.normpath(os.path.dirname(yaml_file))
    else:
        config_data = yaml.safe_load(yaml_str)
    self._load_dict(config_data, base_path)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="delta.config.config.DeltaConfigComponent" href="#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></b></code>:
<ul class="hlist">
<li><code><a title="delta.config.config.DeltaConfigComponent.export" href="#delta.config.config.DeltaConfigComponent.export">export</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.parse_args" href="#delta.config.config.DeltaConfigComponent.parse_args">parse_args</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_arg" href="#delta.config.config.DeltaConfigComponent.register_arg">register_arg</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_component" href="#delta.config.config.DeltaConfigComponent.register_component">register_component</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_field" href="#delta.config.config.DeltaConfigComponent.register_field">register_field</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.reset" href="#delta.config.config.DeltaConfigComponent.reset">reset</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.setup_arg_parser" href="#delta.config.config.DeltaConfigComponent.setup_arg_parser">setup_arg_parser</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.to_dict" href="#delta.config.config.DeltaConfigComponent.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="delta.config.config.DeltaConfigComponent"><code class="flex name class">
<span>class <span class="ident">DeltaConfigComponent</span></span>
<span>(</span><span>section_header=None)</span>
</code></dt>
<dd>
<div class="desc"><p>DELTA configuration component.</p>
<p>Handles one subsection of a config file. Generally subclasses
will want to register fields and components in the constructor,
and possibly override setup_arg_parser and parse_args to handle
command line options.</p>
<p>section_header is the title of the section for command line
arguments in the help.</p>
<p>Constructs the component.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeltaConfigComponent:
    &#34;&#34;&#34;
    DELTA configuration component.

    Handles one subsection of a config file. Generally subclasses
    will want to register fields and components in the constructor,
    and possibly override setup_arg_parser and parse_args to handle
    command line options.

    section_header is the title of the section for command line
    arguments in the help.
    &#34;&#34;&#34;
    def __init__(self, section_header = None):
        &#34;&#34;&#34;
        Constructs the component.
        &#34;&#34;&#34;
        self._config_dict = {}
        self._components = {}
        self._fields = []
        self._validate = {}
        self._types = {}
        self._cmd_args = {}
        self._descs = {}
        self._section_header = section_header

    def reset(self):
        &#34;&#34;&#34;
        Resets all state in the component.
        &#34;&#34;&#34;
        self._config_dict = {}
        for c in self._components.values():
            c.reset()

    def register_component(self, component, name : str, attr_name = None):
        &#34;&#34;&#34;
        Register a subcomponent with a name and attribute name (access as self.attr_name)
        &#34;&#34;&#34;
        assert name not in self._components
        self._components[name] = component
        if attr_name is None:
            attr_name = name
        setattr(self, attr_name, component)

    def register_field(self, name : str, types, accessor = None, validate_fn = None, desc = None):
        &#34;&#34;&#34;
        Register a field in this component of the configuration.

        types is a single type or a tuple of valid types

        validate_fn (optional) should take two strings as input, the field&#39;s value and
        the base directory, and return what to save to the config dictionary.
        It should raise an exception if the field is invalid.
        accessor is an optional name to create an accessor function with
        &#34;&#34;&#34;
        self._fields.append(name)
        self._validate[name] = validate_fn
        self._types[name] = types
        self._descs[name] = desc
        if accessor:
            def access(self) -&gt; types:
                return self._config_dict[name]#pylint:disable=protected-access
            access.__name__ = accessor
            access.__doc__ = desc
            setattr(self.__class__, accessor, access)

    def register_arg(self, field, argname, **kwargs):
        &#34;&#34;&#34;
        Registers a command line argument in this component.

        field is the (registered) field this argument modifies.
        argname is the name of the flag on the command line (i.e., &#39;--flag&#39;)
        **kwargs are arguments to ArgumentParser.add_argument.

        If help and type are not specified, will use the ones for the field.
        If default is not specified, will use the value from the config files.
        &#34;&#34;&#34;
        assert field in self._fields, &#39;Field %s not registered.&#39; % (field)
        if &#39;help&#39; not in kwargs:
            kwargs[&#39;help&#39;] = self._descs[field]
        if &#39;type&#39; not in kwargs:
            kwargs[&#39;type&#39;] = self._types[field]
        elif kwargs[&#39;type&#39;] is None:
            del kwargs[&#39;type&#39;]
        if &#39;default&#39; not in kwargs:
            kwargs[&#39;default&#39;] = _NotSpecified
        self._cmd_args[argname] = (field, kwargs)

    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;
        Returns a dictionary representing the config object.
        &#34;&#34;&#34;
        if isinstance(self._config_dict, dict):
            exp = self._config_dict.copy()
            for (name, c) in self._components.items():
                exp[name] = c.to_dict()
            return exp
        return self._config_dict

    def export(self) -&gt; str:
        &#34;&#34;&#34;
        Returns a YAML string of all configuration options, from to_dict.
        &#34;&#34;&#34;
        return yaml.dump(self.to_dict())

    def _set_field(self, name : str, value : str, base_dir : str):
        if name not in self._fields:
            raise ValueError(&#39;Unexpected field %s in config file.&#39; % (name))
        if value is not None and not isinstance(value, self._types[name]):
            raise TypeError(&#39;%s must be of type %s, is %s.&#39; % (name, self._types[name], value))
        if self._validate[name] and value is not None:
            try:
                value = self._validate[name](value, base_dir)
            except:
                print(&#39;Value %s for %s is invalid.&#39; % (value, name))
                raise
        self._config_dict[name] = value

    def _load_dict(self, d : dict, base_dir):
        &#34;&#34;&#34;
        Loads the dictionary d, assuming it came from the given base_dir (for relative paths).
        &#34;&#34;&#34;
        for (k, v) in d.items():
            if k in self._components:
                self._components[k]._load_dict(v, base_dir) #pylint:disable=protected-access
            else:
                self._set_field(k, v, base_dir)

    def setup_arg_parser(self, parser, components = None) -&gt; None:
        &#34;&#34;&#34;
        Adds arguments to the parser. Must overridden by child classes.
        &#34;&#34;&#34;
        if self._section_header is not None:
            parser = parser.add_argument_group(self._section_header)
        for (arg, value) in self._cmd_args.items():
            (field, kwargs) = value
            parser.add_argument(arg, dest=field, **kwargs)

        for (name, c) in self._components.items():
            if components is None or name in components:
                c.setup_arg_parser(parser)

    def parse_args(self, options):
        &#34;&#34;&#34;
        Parse options extracted from an ArgParser configured with
        `setup_arg_parser` and override the appropriate
        configuration values.
        &#34;&#34;&#34;
        d = {}
        for (field, _) in self._cmd_args.values():
            if not hasattr(options, field) or getattr(options, field) is None:
                continue
            if getattr(options, field) is _NotSpecified:
                continue
            d[field] = getattr(options, field)
        self._load_dict(d, None)

        for c in self._components.values():
            c.parse_args(options)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="delta.config.config.DeltaConfig" href="#delta.config.config.DeltaConfig">DeltaConfig</a></li>
<li><a title="delta.imagery.imagery_config.CacheConfig" href="../imagery/imagery_config.html#delta.imagery.imagery_config.CacheConfig">CacheConfig</a></li>
<li><a title="delta.imagery.imagery_config.ClassesConfig" href="../imagery/imagery_config.html#delta.imagery.imagery_config.ClassesConfig">ClassesConfig</a></li>
<li><a title="delta.imagery.imagery_config.DatasetConfig" href="../imagery/imagery_config.html#delta.imagery.imagery_config.DatasetConfig">DatasetConfig</a></li>
<li><a title="delta.imagery.imagery_config.IOConfig" href="../imagery/imagery_config.html#delta.imagery.imagery_config.IOConfig">IOConfig</a></li>
<li><a title="delta.imagery.imagery_config.ImagePreprocessConfig" href="../imagery/imagery_config.html#delta.imagery.imagery_config.ImagePreprocessConfig">ImagePreprocessConfig</a></li>
<li><a title="delta.imagery.imagery_config.ImageSetConfig" href="../imagery/imagery_config.html#delta.imagery.imagery_config.ImageSetConfig">ImageSetConfig</a></li>
<li><a title="delta.ml.ml_config.MLFlowCheckpointsConfig" href="../ml/ml_config.html#delta.ml.ml_config.MLFlowCheckpointsConfig">MLFlowCheckpointsConfig</a></li>
<li><a title="delta.ml.ml_config.MLFlowConfig" href="../ml/ml_config.html#delta.ml.ml_config.MLFlowConfig">MLFlowConfig</a></li>
<li><a title="delta.ml.ml_config.NetworkConfig" href="../ml/ml_config.html#delta.ml.ml_config.NetworkConfig">NetworkConfig</a></li>
<li><a title="delta.ml.ml_config.NetworkModelConfig" href="../ml/ml_config.html#delta.ml.ml_config.NetworkModelConfig">NetworkModelConfig</a></li>
<li><a title="delta.ml.ml_config.TensorboardConfig" href="../ml/ml_config.html#delta.ml.ml_config.TensorboardConfig">TensorboardConfig</a></li>
<li><a title="delta.ml.ml_config.TrainingConfig" href="../ml/ml_config.html#delta.ml.ml_config.TrainingConfig">TrainingConfig</a></li>
<li><a title="delta.ml.ml_config.ValidationConfig" href="../ml/ml_config.html#delta.ml.ml_config.ValidationConfig">ValidationConfig</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="delta.config.config.DeltaConfigComponent.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a YAML string of all configuration options, from to_dict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self) -&gt; str:
    &#34;&#34;&#34;
    Returns a YAML string of all configuration options, from to_dict.
    &#34;&#34;&#34;
    return yaml.dump(self.to_dict())</code></pre>
</details>
</dd>
<dt id="delta.config.config.DeltaConfigComponent.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>self, options)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse options extracted from an ArgParser configured with
<code>setup_arg_parser</code> and override the appropriate
configuration values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_args(self, options):
    &#34;&#34;&#34;
    Parse options extracted from an ArgParser configured with
    `setup_arg_parser` and override the appropriate
    configuration values.
    &#34;&#34;&#34;
    d = {}
    for (field, _) in self._cmd_args.values():
        if not hasattr(options, field) or getattr(options, field) is None:
            continue
        if getattr(options, field) is _NotSpecified:
            continue
        d[field] = getattr(options, field)
    self._load_dict(d, None)

    for c in self._components.values():
        c.parse_args(options)</code></pre>
</details>
</dd>
<dt id="delta.config.config.DeltaConfigComponent.register_arg"><code class="name flex">
<span>def <span class="ident">register_arg</span></span>(<span>self, field, argname, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Registers a command line argument in this component.</p>
<p>field is the (registered) field this argument modifies.
argname is the name of the flag on the command line (i.e., '&ndash;flag')
**kwargs are arguments to ArgumentParser.add_argument.</p>
<p>If help and type are not specified, will use the ones for the field.
If default is not specified, will use the value from the config files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_arg(self, field, argname, **kwargs):
    &#34;&#34;&#34;
    Registers a command line argument in this component.

    field is the (registered) field this argument modifies.
    argname is the name of the flag on the command line (i.e., &#39;--flag&#39;)
    **kwargs are arguments to ArgumentParser.add_argument.

    If help and type are not specified, will use the ones for the field.
    If default is not specified, will use the value from the config files.
    &#34;&#34;&#34;
    assert field in self._fields, &#39;Field %s not registered.&#39; % (field)
    if &#39;help&#39; not in kwargs:
        kwargs[&#39;help&#39;] = self._descs[field]
    if &#39;type&#39; not in kwargs:
        kwargs[&#39;type&#39;] = self._types[field]
    elif kwargs[&#39;type&#39;] is None:
        del kwargs[&#39;type&#39;]
    if &#39;default&#39; not in kwargs:
        kwargs[&#39;default&#39;] = _NotSpecified
    self._cmd_args[argname] = (field, kwargs)</code></pre>
</details>
</dd>
<dt id="delta.config.config.DeltaConfigComponent.register_component"><code class="name flex">
<span>def <span class="ident">register_component</span></span>(<span>self, component, name: str, attr_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Register a subcomponent with a name and attribute name (access as self.attr_name)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_component(self, component, name : str, attr_name = None):
    &#34;&#34;&#34;
    Register a subcomponent with a name and attribute name (access as self.attr_name)
    &#34;&#34;&#34;
    assert name not in self._components
    self._components[name] = component
    if attr_name is None:
        attr_name = name
    setattr(self, attr_name, component)</code></pre>
</details>
</dd>
<dt id="delta.config.config.DeltaConfigComponent.register_field"><code class="name flex">
<span>def <span class="ident">register_field</span></span>(<span>self, name: str, types, accessor=None, validate_fn=None, desc=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Register a field in this component of the configuration.</p>
<p>types is a single type or a tuple of valid types</p>
<p>validate_fn (optional) should take two strings as input, the field's value and
the base directory, and return what to save to the config dictionary.
It should raise an exception if the field is invalid.
accessor is an optional name to create an accessor function with</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def register_field(self, name : str, types, accessor = None, validate_fn = None, desc = None):
    &#34;&#34;&#34;
    Register a field in this component of the configuration.

    types is a single type or a tuple of valid types

    validate_fn (optional) should take two strings as input, the field&#39;s value and
    the base directory, and return what to save to the config dictionary.
    It should raise an exception if the field is invalid.
    accessor is an optional name to create an accessor function with
    &#34;&#34;&#34;
    self._fields.append(name)
    self._validate[name] = validate_fn
    self._types[name] = types
    self._descs[name] = desc
    if accessor:
        def access(self) -&gt; types:
            return self._config_dict[name]#pylint:disable=protected-access
        access.__name__ = accessor
        access.__doc__ = desc
        setattr(self.__class__, accessor, access)</code></pre>
</details>
</dd>
<dt id="delta.config.config.DeltaConfigComponent.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets all state in the component.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    &#34;&#34;&#34;
    Resets all state in the component.
    &#34;&#34;&#34;
    self._config_dict = {}
    for c in self._components.values():
        c.reset()</code></pre>
</details>
</dd>
<dt id="delta.config.config.DeltaConfigComponent.setup_arg_parser"><code class="name flex">
<span>def <span class="ident">setup_arg_parser</span></span>(<span>self, parser, components=None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Adds arguments to the parser. Must overridden by child classes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_arg_parser(self, parser, components = None) -&gt; None:
    &#34;&#34;&#34;
    Adds arguments to the parser. Must overridden by child classes.
    &#34;&#34;&#34;
    if self._section_header is not None:
        parser = parser.add_argument_group(self._section_header)
    for (arg, value) in self._cmd_args.items():
        (field, kwargs) = value
        parser.add_argument(arg, dest=field, **kwargs)

    for (name, c) in self._components.items():
        if components is None or name in components:
            c.setup_arg_parser(parser)</code></pre>
</details>
</dd>
<dt id="delta.config.config.DeltaConfigComponent.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary representing the config object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self) -&gt; dict:
    &#34;&#34;&#34;
    Returns a dictionary representing the config object.
    &#34;&#34;&#34;
    if isinstance(self._config_dict, dict):
        exp = self._config_dict.copy()
        for (name, c) in self._components.items():
            exp[name] = c.to_dict()
        return exp
    return self._config_dict</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="delta.config" href="index.html">delta.config</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="delta.config.config.validate_path" href="#delta.config.config.validate_path">validate_path</a></code></li>
<li><code><a title="delta.config.config.validate_positive" href="#delta.config.config.validate_positive">validate_positive</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="delta.config.config.DeltaConfig" href="#delta.config.config.DeltaConfig">DeltaConfig</a></code></h4>
<ul class="">
<li><code><a title="delta.config.config.DeltaConfig.initialize" href="#delta.config.config.DeltaConfig.initialize">initialize</a></code></li>
<li><code><a title="delta.config.config.DeltaConfig.load" href="#delta.config.config.DeltaConfig.load">load</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="delta.config.config.DeltaConfigComponent" href="#delta.config.config.DeltaConfigComponent">DeltaConfigComponent</a></code></h4>
<ul class="two-column">
<li><code><a title="delta.config.config.DeltaConfigComponent.export" href="#delta.config.config.DeltaConfigComponent.export">export</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.parse_args" href="#delta.config.config.DeltaConfigComponent.parse_args">parse_args</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_arg" href="#delta.config.config.DeltaConfigComponent.register_arg">register_arg</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_component" href="#delta.config.config.DeltaConfigComponent.register_component">register_component</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.register_field" href="#delta.config.config.DeltaConfigComponent.register_field">register_field</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.reset" href="#delta.config.config.DeltaConfigComponent.reset">reset</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.setup_arg_parser" href="#delta.config.config.DeltaConfigComponent.setup_arg_parser">setup_arg_parser</a></code></li>
<li><code><a title="delta.config.config.DeltaConfigComponent.to_dict" href="#delta.config.config.DeltaConfigComponent.to_dict">to_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>