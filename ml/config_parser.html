<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>delta.ml.config_parser API documentation</title>
<meta name="description" content="Functions to support loading custom ML-related objects from dictionaries specified
in yaml files. Includes constructing custom neural networks and more." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>delta.ml.config_parser</code></h1>
</header>
<section id="section-intro">
<p>Functions to support loading custom ML-related objects from dictionaries specified
in yaml files. Includes constructing custom neural networks and more.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright © 2020, United States Government, as represented by the
# Administrator of the National Aeronautics and Space Administration.
# All rights reserved.
#
# The DELTA (Deep Earth Learning, Tools, and Analysis) platform is
# licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#        http://www.apache.org/licenses/LICENSE-2.0.
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;
Functions to support loading custom ML-related objects from dictionaries specified
in yaml files. Includes constructing custom neural networks and more.
&#34;&#34;&#34;
from collections.abc import Mapping
import copy
import functools
from typing import Callable, List, Union

import tensorflow
import tensorflow.keras.layers
import tensorflow.keras.losses
import tensorflow.keras.models

from delta.config import config
import delta.config.extensions as extensions

class _LayerWrapper:
    def __init__(self, layer_type, layer_name, inputs, params, all_layers):
        &#34;&#34;&#34;
        all_layers is a name indexed dictionary of LayerWrappers for all the layers,
        shared between them.
        &#34;&#34;&#34;
        self._layer_type = layer_type
        self.name = layer_name
        self._inputs = inputs
        lc = extensions.layer(layer_type)
        if lc is None:
            lc = getattr(tensorflow.keras.layers, layer_type, None)
        if lc is None:
            raise ValueError(&#39;Unknown layer type %s.&#39; % (layer_type))
        self.layer = lc(**params)
        self._sub_layers = None
        self._tensor = None
        all_layers[layer_name] = self
        self._all_layers = all_layers

    def is_input(self):
        return self._layer_type == &#39;Input&#39;

    def sub_layer(self, name):
        assert self._sub_layers, &#39;Layer %s does not support sub-layers.&#39; % (self.layer.name)
        assert name in self._sub_layers, (&#39;Layer %s not found in &#39; % (name)) + str(self._sub_layers)
        return self._sub_layers[name]

    # TODO: will crash if there is a cycle in the graph
    def output_tensor(self):
        &#34;&#34;&#34;
        Constructs the output tensor with preceding layers as inputs.
        &#34;&#34;&#34;
        if self._tensor is not None:
            return self._tensor
        inputs = []
        for k in self._inputs:
            if isinstance(k, tensorflow.Tensor):
                inputs.append(k)
                continue
            if isinstance(k, int) or &#39;/&#39; not in k:
                l = self._all_layers[k].output_tensor()
                inputs.append(l)
                continue
            # getting nested layer
            parts = k.split(&#39;/&#39;)
            input_layer = parts[0]
            if input_layer not in self._all_layers:
                raise ValueError(&#39;Input layer &#39; + str(input_layer) + &#39; not found.&#39;)
            self._all_layers[input_layer].output_tensor() # compute it if it hasn&#39;t been
            cur = self._all_layers[input_layer].sub_layer(k[len(parts[0]) + 1:])

            if isinstance(self._tensor, tensorflow.keras.layers.Layer):
                inputs.append(cur.output)
            else:
                inputs.append(cur)
        if inputs:
            if len(inputs) == 1:
                inputs = inputs[0]
            self._tensor = self.layer(inputs)
            if isinstance(self._tensor, tuple):
                self._sub_layers = self._tensor[1]
                self._tensor = self._tensor[0]
            if isinstance(self._tensor, tensorflow.keras.layers.Layer):
                self._tensor = self._tensor.output
        else:
            self._tensor = self.layer
        return self._tensor

def _make_layer(layer_dict, layer_id, prev_layer, all_layers):
    &#34;&#34;&#34;
    Constructs a layer specified in layer_dict.
    layer_id is the order in the order in the config file.
    Assumes layer_dict only contains the key which is the
    layer type, mapped to a sub-dict with properly named parameters for constructing
    the layer, and the additional fields:

     * `name` (optional): a name to refer to the layer by
     * `inputs` (optional): the name or a list of names of
       the preceding layers (defaults to previous in list)
    &#34;&#34;&#34;
    if len(layer_dict.keys()) &gt; 1:
        raise ValueError(&#39;Layer with multiple types.&#39;)
    layer_type = next(layer_dict.keys().__iter__())
    l = layer_dict[layer_type]
    if l is None:
        l = {}

    inputs = [prev_layer]
    if layer_type == &#39;Input&#39;:
        inputs = []
    if &#39;name&#39; in l:
        layer_id = l[&#39;name&#39;]
    if &#39;inputs&#39; in l:
        inputs = l[&#39;inputs&#39;]
        l = copy.copy(l) # don&#39;t modify original dict
        del l[&#39;inputs&#39;]
        if isinstance(inputs, (int, str)):
            inputs = [inputs]

    return _LayerWrapper(layer_type, layer_id, inputs, l, all_layers)

def _make_model(layer_list):
    &#34;&#34;&#34;
    Makes a model from a list of layers.
    &#34;&#34;&#34;
    assert layer_list is not None, &#39;No model specified!&#39;

    prev_layer = 0
    last = None
    all_layers = {}
    for (i, l) in enumerate(layer_list):
        last = _make_layer(l, i, prev_layer, all_layers)
        prev_layer = last.name

    outputs = last.output_tensor()
    inputs = [l.output_tensor() for l in all_layers.values() if l.is_input()]

    if len(inputs) == 1:
        inputs = inputs[0]
    return tensorflow.keras.models.Model(inputs=inputs, outputs=outputs)

def _apply_params(model_dict, exposed_params):
    &#34;&#34;&#34;
    Apply the parameters in exposed_params and in model_dict[&#39;params&#39;]
    to the fields in model_dict, returning a copy.
    &#34;&#34;&#34;
    defined_params = {}
    if &#39;params&#39; in model_dict and model_dict[&#39;params&#39;] is not None:
        defined_params = model_dict[&#39;params&#39;]

    params = {**exposed_params, **defined_params}
    # replace parameters recursively in all layers
    def recursive_dict_list_apply(d, func):
        if isinstance(d, Mapping):
            for k, v in d.items():
                d[k] = recursive_dict_list_apply(v, func)
            return d
        if isinstance(d, list):
            return list(map(functools.partial(recursive_dict_list_apply, func=func), d))
        if isinstance(d, str):
            return func(d)
        return d
    def apply_params(s):
        for (k, v) in params.items():
            if s == k:
                return v
        return s
    model_dict_copy = copy.deepcopy(model_dict)
    recursive_dict_list_apply(model_dict_copy, apply_params)

    # checks if the first layer is an Input, if not insert one
    layer_list = model_dict_copy[&#39;layers&#39;]
    assert layer_list is not None, &#39;No model specified!&#39;
    first_layer_type = next(layer_list[0].keys().__iter__())
    if first_layer_type != &#39;Input&#39; and &#39;input&#39; not in layer_list[0][first_layer_type]:
        model_dict_copy[&#39;layers&#39;] = [{&#39;Input&#39; : {&#39;shape&#39; : params[&#39;in_shape&#39;]}}] + layer_list

    return model_dict_copy

def model_from_dict(model_dict: dict, exposed_params: dict) -&gt; Callable[[], tensorflow.keras.models.Model]:
    &#34;&#34;&#34;
    Construct a model.

    Parameters
    ----------
    model_dict: dict
        Config dictionary describing the model
    exposed_params: dict
        Dictionary of parameter names and values to substitute.

    Returns
    -------
    Callable[[], tensorflow.keras.models.Model]:
        Model constructor function.
    &#34;&#34;&#34;
    model_dict = _apply_params(model_dict, exposed_params)
    return functools.partial(_make_model, model_dict[&#39;layers&#39;])

def _parse_str_or_dict(spec, type_name):
    if isinstance(spec, str):
        return (spec, {})
    if isinstance(spec, dict):
        assert len(spec.keys()) == 1, &#39;Only one %s may be specified.&#39; % (type_name)
        name = list(spec.keys())[0]
        return (name, spec[name])
    raise ValueError(&#39;Unexpected entry for %s.&#39; % (type_name))

def loss_from_dict(loss_spec: Union[dict, str]) -&gt; tensorflow.keras.losses.Loss:
    &#34;&#34;&#34;
    Construct a loss function.

    Parameters
    ----------
    loss_spec: Union[dict, str]
        Specification of the loss function.  Either a string that is compatible
        with the keras interface (e.g. &#39;categorical_crossentropy&#39;) or an object defined by a dict
        of the form {&#39;LossFunctionName&#39;: {&#39;arg1&#39;:arg1_val, ...,&#39;argN&#39;,argN_val}}

    Returns
    -------
    tensorflow.keras.losses.Loss
        The loss object.
    &#34;&#34;&#34;
    (name, params) = _parse_str_or_dict(loss_spec, &#39;loss function&#39;)
    lc = extensions.loss(name)
    if lc is None:
        lc = getattr(tensorflow.keras.losses, name, None)
    if lc is None:
        raise ValueError(&#39;Unknown loss type %s.&#39; % (name))
    if isinstance(lc, type) and issubclass(lc, tensorflow.keras.losses.Loss):
        lc = lc(**params)
    return lc

def metric_from_dict(metric_spec: Union[dict, str]) -&gt; tensorflow.keras.metrics.Metric:
    &#34;&#34;&#34;
    Construct a metric.

    Parameters
    ----------
    metric_spec: Union[dict, str]
        Config dictionary or string defining the metric

    Returns
    -------
    tensorflow.keras.metrics.Metric
        The metric object.
    &#34;&#34;&#34;
    (name, params) = _parse_str_or_dict(metric_spec, &#39;metric&#39;)
    mc = extensions.metric(name)
    if mc is None:
        mc = getattr(tensorflow.keras.metrics, name, None)
    if mc is None:
        try:
            mc = loss_from_dict(metric_spec)
        except:
            raise ValueError(&#39;Unknown metric %s.&#39; % (name)) #pylint:disable=raise-missing-from
    if isinstance(mc, type) and issubclass(mc, tensorflow.keras.metrics.Metric):
        mc = mc(**params)
    return mc

def optimizer_from_dict(spec: Union[dict, str]) -&gt; tensorflow.keras.optimizers.Optimizer:
    &#34;&#34;&#34;
    Construct an optimizer from a dictionary or string.

    Parameters
    ----------
    spec: Union[dict, str]
        Config dictionary  or string defining an optimizer

    Returns
    -------
    tensorflow.keras.optimizers.Optimizer
        The optimizer object.
    &#34;&#34;&#34;
    (name, params) = _parse_str_or_dict(spec, &#39;optimizer&#39;)
    mc = getattr(tensorflow.keras.optimizers, name, None)
    if mc is None:
        raise ValueError(&#39;Unknown optimizer %s.&#39; % (name))
    return mc(**params)

def callback_from_dict(callback_dict: Union[dict, str]) -&gt; tensorflow.keras.callbacks.Callback:
    &#34;&#34;&#34;
    Construct a callback from a dictionary.

    Parameters
    ----------
    callback_dict: Union[dict, str]
        Config dictionary defining a callback.

    Returns
    -------
    tensorflow.keras.callbacks.Callback
        The callback object.
    &#34;&#34;&#34;
    assert len(callback_dict.keys()) == 1, f&#39;Error: Callback has more than one type {callback_dict.keys()}&#39;

    cb_type = next(iter(callback_dict.keys()))
    callback_class = extensions.callback(cb_type)
    if callback_class is None:
        callback_class = getattr(tensorflow.keras.callbacks, cb_type, None)
    if callback_dict[cb_type] is None:
        callback_dict[cb_type] = {}
    if callback_class is None:
        raise ValueError(&#39;Unknown callback %s.&#39; % (cb_type))
    return callback_class(**callback_dict[cb_type])

def config_callbacks() -&gt; List[tensorflow.keras.callbacks.Callback]:
    &#34;&#34;&#34;
    Returns
    -------
    List[tensorflow.keras.callbacks.Callback]
        List of callbacks specified in the config file.
    &#34;&#34;&#34;
    if not config.train.callbacks() is None:
        return [callback_from_dict(callback) for callback in config.train.callbacks()]
    return []

def config_model(num_bands: int) -&gt; Callable[[], tensorflow.keras.models.Model]:
    &#34;&#34;&#34;
    Returns
    -------
    Callable[[], tensorflow.keras.models.Model]
        A function to construct the model given in the config file.
    &#34;&#34;&#34;
    params_exposed = {&#39;num_classes&#39; : len(config.dataset.classes),
                      &#39;num_bands&#39; : num_bands}

    return model_from_dict(config.train.network.to_dict(), params_exposed)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="delta.ml.config_parser.callback_from_dict"><code class="name flex">
<span>def <span class="ident">callback_from_dict</span></span>(<span>callback_dict: Union[dict, str]) ‑> tensorflow.python.keras.callbacks.Callback</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a callback from a dictionary.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>callback_dict</code></strong> :&ensp;<code>Union[dict, str]</code></dt>
<dd>Config dictionary defining a callback.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tensorflow.keras.callbacks.Callback</code></dt>
<dd>The callback object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def callback_from_dict(callback_dict: Union[dict, str]) -&gt; tensorflow.keras.callbacks.Callback:
    &#34;&#34;&#34;
    Construct a callback from a dictionary.

    Parameters
    ----------
    callback_dict: Union[dict, str]
        Config dictionary defining a callback.

    Returns
    -------
    tensorflow.keras.callbacks.Callback
        The callback object.
    &#34;&#34;&#34;
    assert len(callback_dict.keys()) == 1, f&#39;Error: Callback has more than one type {callback_dict.keys()}&#39;

    cb_type = next(iter(callback_dict.keys()))
    callback_class = extensions.callback(cb_type)
    if callback_class is None:
        callback_class = getattr(tensorflow.keras.callbacks, cb_type, None)
    if callback_dict[cb_type] is None:
        callback_dict[cb_type] = {}
    if callback_class is None:
        raise ValueError(&#39;Unknown callback %s.&#39; % (cb_type))
    return callback_class(**callback_dict[cb_type])</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.config_callbacks"><code class="name flex">
<span>def <span class="ident">config_callbacks</span></span>(<span>) ‑> List[tensorflow.python.keras.callbacks.Callback]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>List[tensorflow.keras.callbacks.Callback]</code></dt>
<dd>List of callbacks specified in the config file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_callbacks() -&gt; List[tensorflow.keras.callbacks.Callback]:
    &#34;&#34;&#34;
    Returns
    -------
    List[tensorflow.keras.callbacks.Callback]
        List of callbacks specified in the config file.
    &#34;&#34;&#34;
    if not config.train.callbacks() is None:
        return [callback_from_dict(callback) for callback in config.train.callbacks()]
    return []</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.config_model"><code class="name flex">
<span>def <span class="ident">config_model</span></span>(<span>num_bands: int) ‑> Callable[[], tensorflow.python.keras.engine.training.Model]</span>
</code></dt>
<dd>
<div class="desc"><h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable[[], tensorflow.keras.models.Model]</code></dt>
<dd>A function to construct the model given in the config file.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_model(num_bands: int) -&gt; Callable[[], tensorflow.keras.models.Model]:
    &#34;&#34;&#34;
    Returns
    -------
    Callable[[], tensorflow.keras.models.Model]
        A function to construct the model given in the config file.
    &#34;&#34;&#34;
    params_exposed = {&#39;num_classes&#39; : len(config.dataset.classes),
                      &#39;num_bands&#39; : num_bands}

    return model_from_dict(config.train.network.to_dict(), params_exposed)</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.loss_from_dict"><code class="name flex">
<span>def <span class="ident">loss_from_dict</span></span>(<span>loss_spec: Union[dict, str]) ‑> tensorflow.python.keras.losses.Loss</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a loss function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loss_spec</code></strong> :&ensp;<code>Union[dict, str]</code></dt>
<dd>Specification of the loss function.
Either a string that is compatible
with the keras interface (e.g. 'categorical_crossentropy') or an object defined by a dict
of the form {'LossFunctionName': {'arg1':arg1_val, &hellip;,'argN',argN_val}}</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tensorflow.keras.losses.Loss</code></dt>
<dd>The loss object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loss_from_dict(loss_spec: Union[dict, str]) -&gt; tensorflow.keras.losses.Loss:
    &#34;&#34;&#34;
    Construct a loss function.

    Parameters
    ----------
    loss_spec: Union[dict, str]
        Specification of the loss function.  Either a string that is compatible
        with the keras interface (e.g. &#39;categorical_crossentropy&#39;) or an object defined by a dict
        of the form {&#39;LossFunctionName&#39;: {&#39;arg1&#39;:arg1_val, ...,&#39;argN&#39;,argN_val}}

    Returns
    -------
    tensorflow.keras.losses.Loss
        The loss object.
    &#34;&#34;&#34;
    (name, params) = _parse_str_or_dict(loss_spec, &#39;loss function&#39;)
    lc = extensions.loss(name)
    if lc is None:
        lc = getattr(tensorflow.keras.losses, name, None)
    if lc is None:
        raise ValueError(&#39;Unknown loss type %s.&#39; % (name))
    if isinstance(lc, type) and issubclass(lc, tensorflow.keras.losses.Loss):
        lc = lc(**params)
    return lc</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.metric_from_dict"><code class="name flex">
<span>def <span class="ident">metric_from_dict</span></span>(<span>metric_spec: Union[dict, str]) ‑> tensorflow.python.keras.metrics.Metric</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a metric.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>metric_spec</code></strong> :&ensp;<code>Union[dict, str]</code></dt>
<dd>Config dictionary or string defining the metric</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tensorflow.keras.metrics.Metric</code></dt>
<dd>The metric object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def metric_from_dict(metric_spec: Union[dict, str]) -&gt; tensorflow.keras.metrics.Metric:
    &#34;&#34;&#34;
    Construct a metric.

    Parameters
    ----------
    metric_spec: Union[dict, str]
        Config dictionary or string defining the metric

    Returns
    -------
    tensorflow.keras.metrics.Metric
        The metric object.
    &#34;&#34;&#34;
    (name, params) = _parse_str_or_dict(metric_spec, &#39;metric&#39;)
    mc = extensions.metric(name)
    if mc is None:
        mc = getattr(tensorflow.keras.metrics, name, None)
    if mc is None:
        try:
            mc = loss_from_dict(metric_spec)
        except:
            raise ValueError(&#39;Unknown metric %s.&#39; % (name)) #pylint:disable=raise-missing-from
    if isinstance(mc, type) and issubclass(mc, tensorflow.keras.metrics.Metric):
        mc = mc(**params)
    return mc</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.model_from_dict"><code class="name flex">
<span>def <span class="ident">model_from_dict</span></span>(<span>model_dict: dict, exposed_params: dict) ‑> Callable[[], tensorflow.python.keras.engine.training.Model]</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Config dictionary describing the model</dd>
<dt><strong><code>exposed_params</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of parameter names and values to substitute.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Callable[[], tensorflow.keras.models.Model]:</code></dt>
<dd>Model constructor function.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_from_dict(model_dict: dict, exposed_params: dict) -&gt; Callable[[], tensorflow.keras.models.Model]:
    &#34;&#34;&#34;
    Construct a model.

    Parameters
    ----------
    model_dict: dict
        Config dictionary describing the model
    exposed_params: dict
        Dictionary of parameter names and values to substitute.

    Returns
    -------
    Callable[[], tensorflow.keras.models.Model]:
        Model constructor function.
    &#34;&#34;&#34;
    model_dict = _apply_params(model_dict, exposed_params)
    return functools.partial(_make_model, model_dict[&#39;layers&#39;])</code></pre>
</details>
</dd>
<dt id="delta.ml.config_parser.optimizer_from_dict"><code class="name flex">
<span>def <span class="ident">optimizer_from_dict</span></span>(<span>spec: Union[dict, str]) ‑> tensorflow.python.keras.optimizer_v2.optimizer_v2.OptimizerV2</span>
</code></dt>
<dd>
<div class="desc"><p>Construct an optimizer from a dictionary or string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spec</code></strong> :&ensp;<code>Union[dict, str]</code></dt>
<dd>Config dictionary
or string defining an optimizer</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tensorflow.keras.optimizers.Optimizer</code></dt>
<dd>The optimizer object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimizer_from_dict(spec: Union[dict, str]) -&gt; tensorflow.keras.optimizers.Optimizer:
    &#34;&#34;&#34;
    Construct an optimizer from a dictionary or string.

    Parameters
    ----------
    spec: Union[dict, str]
        Config dictionary  or string defining an optimizer

    Returns
    -------
    tensorflow.keras.optimizers.Optimizer
        The optimizer object.
    &#34;&#34;&#34;
    (name, params) = _parse_str_or_dict(spec, &#39;optimizer&#39;)
    mc = getattr(tensorflow.keras.optimizers, name, None)
    if mc is None:
        raise ValueError(&#39;Unknown optimizer %s.&#39; % (name))
    return mc(**params)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="delta.ml" href="index.html">delta.ml</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="delta.ml.config_parser.callback_from_dict" href="#delta.ml.config_parser.callback_from_dict">callback_from_dict</a></code></li>
<li><code><a title="delta.ml.config_parser.config_callbacks" href="#delta.ml.config_parser.config_callbacks">config_callbacks</a></code></li>
<li><code><a title="delta.ml.config_parser.config_model" href="#delta.ml.config_parser.config_model">config_model</a></code></li>
<li><code><a title="delta.ml.config_parser.loss_from_dict" href="#delta.ml.config_parser.loss_from_dict">loss_from_dict</a></code></li>
<li><code><a title="delta.ml.config_parser.metric_from_dict" href="#delta.ml.config_parser.metric_from_dict">metric_from_dict</a></code></li>
<li><code><a title="delta.ml.config_parser.model_from_dict" href="#delta.ml.config_parser.model_from_dict">model_from_dict</a></code></li>
<li><code><a title="delta.ml.config_parser.optimizer_from_dict" href="#delta.ml.config_parser.optimizer_from_dict">optimizer_from_dict</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>